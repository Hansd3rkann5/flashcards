<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#0a0f1e" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-title" content="Flashcards" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Engineering Flashcards | Shared Server</title>
  <link rel="icon" type="image/png" href="icons/icon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png" />
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxYkQJvRV6A7vA3HfNdc0AGJi/7luWGINuD/7++UZ5EONosFVJeFt3uTJS3BM4" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    integrity="sha384-hIoBPJpTUsM8c7kwh28ykVfoCENKz7LxyzKDn5XxhxL7sRKqzZo4PM5XgS5aXoaZ"
    crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    integrity="sha384-hCXGrW6PitU8M1uuvvZp8K4D4ew3Efr2E1VlzDq+W8sELpAo0P5PLf4KJIp4jOSy"
    crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</head>

<body>
  <div id="sidebarOverlay" class="sidebar-overlay" aria-hidden="true"></div>
  <aside class="sidebar">
    <div>
      <div class="app-title">‚öôÔ∏è Engineering Flashcards</div>
    </div>
    <button id="homeBtn">üè† Home</button>
    <button id="settingsBtn">‚öôÔ∏è Settings</button>
    <div>
      <strong>Subjects</strong>
      <div id="subjectList" class="tile-grid"></div>
      <button class="btn" id="addSubjectBtn" style="margin-top:10px;width: 100%;">+ Add Subject</button>
    </div>
  </aside>

  <main class="main">
    <div id="track" class="track">
      <section class="panel" id="homePanel">
        <div id="dailyReviewHomePanel" class="section daily-review-home hidden">
          <div class="editor-header">
            <button class="btn subject-sidebar-toggle review-sidebar-toggle" id="sidebarToggleHome" type="button"
              aria-label="Open sidebar" title="Open sidebar">
              <img src="icons/burger.svg" alt="" aria-hidden="true" />
            </button>
            <h3>Review Cards</h3>
          </div>
          <div class="session-complete-message" id="dailyReviewMessage">
            Start a short review based on your latest saved card status.
          </div>
          <div class="session-complete-stats">
            <div class="session-complete-stat">
              <div class="tiny">Answered Cards</div>
              <strong id="dailyReviewTotalCards">0</strong>
            </div>
            <div class="session-complete-stat">
              <div class="tiny">Topics Included</div>
              <strong id="dailyReviewTotalTopics">0</strong>
            </div>
          </div>
          <div class="tiny">Status Filter (latest saved state)</div>
          <div id="dailyReviewStatusFilters" class="session-filter-list daily-review-status-list">
            <label class="session-filter-option daily-review-status-option" style="background-color: var(--success)">
              <input id="dailyReviewFilterGreen" type="checkbox" checked />
              <span>Green</span>
            </label>
            <label class="session-filter-option daily-review-status-option" style="background-color: var(--warn)">
              <input id="dailyReviewFilterYellow" type="checkbox" />
              <span>Yellow</span>
            </label>
            <label class="session-filter-option daily-review-status-option" style="background-color: var(--danger)">
              <input id="dailyReviewFilterRed" type="checkbox" />
              <span>Red</span>
            </label>
          </div>
          <div class="tiny" id="dailyReviewFilterMeta" style="margin-bottom:8px;">Status: Green</div>
          <div class="tiny" id="dailyReviewSelectionMeta" style="margin-bottom:8px;">0 topics selected ‚Ä¢ 0 cards</div>
          <div id="dailyReviewTopicList" class="session-filter-list daily-review-topic-list"></div>
          <div class="session-repeat-controls">
            <div class="tiny">Session Size</div>
            <div class="counter">
              <button class="btn counter-btn" id="dailyReviewMinus" type="button">-</button>
              <div class="counter-value" id="dailyReviewSizeValue">0 / 0</div>
              <button class="btn counter-btn" id="dailyReviewPlus" type="button">+</button>
            </div>
          </div>
          <div class="controls" style="margin-top:14px; margin-inline: 0">
            <button class="btn start-daily-review-btn" id="startDailyReviewBtn" type="button">Start Review</button>
          </div>
        </div>
      </section>

      <section class="panel" id="topicPanel">
        <div class="section">
          <div class="topic-sticky-stack">
            <div class="controls topic-header" style="align-items:center;margin-inline: 0; ">
              <button class="btn subject-sidebar-toggle" id="sidebarToggle" type="button" aria-label="Open sidebar"
                title="Open sidebar">
                <img src="icons/burger.svg" alt="" aria-hidden="true" />
              </button>
              <h2 id="topicTitle" style="margin:0;">Subject</h2>
            </div>
          </div>
          <div class="study-selection section">
            <h3>Study Session</h3>
            <div class="grid two study-selection-grid">
              <div class="study-selection-card">
                <label>Session Size</label>
                <div class="counter">
                  <button class="btn counter-btn" id="sessionMinus">-</button>
                  <div class="counter-value" id="sessionSizeValue">15</div>
                  <button class="btn counter-btn" id="sessionPlus">+</button>
                </div>
                <div class="tiny">Pick how many cards to study this session.</div>
              </div>
              <div class="study-selection-card">
                <label>Selected Topics</label>
                <div id="selectedTopicsSummary" class="selected-topics-summary is-empty">Choose topics below (you can
                  mix multiple).</div>
              </div>
            </div>
            <div class="study-session-actions">
              <button class="btn" id="startSessionBtn" type="button">‚ñ∂ Start Session</button>
              <button class="btn" id="openSessionFilterBtn" type="button">Filter</button>
            </div>
            <div class="tiny session-filter-summary" id="sessionFilterSummary"></div>
          </div>
          <div class="topic-list-head">
            <h3 id="topicListTitle" class="topic-list-title">Topics</h3>
            <div class="topic-list-actions">
              <button class="btn select-cards-btn topic-search-btn" id="openTopicSearchBtn" aria-label="Search cards"
                title="Search cards" type="button">
                <img src="icons/icons8-suche-48.svg" alt="" />
              </button>
              <button class="btn select-cards-btn" id="toggleTopicSelectBtn" aria-label="Select topics"
                title="Select topics" type="button">
                <img src="icons/icons8-ha%CC%88kchen.svg" alt="" />
              </button>
            </div>
          </div>
          <div class="topic-bulk-actions hidden" id="topicBulkActions">
            <div class="tiny" id="topicSelectionCount">0 topics selected</div>
            <button class="btn" id="moveSelectedTopicsBtn" type="button">Move</button>
            <button class="btn delete" id="deleteSelectedTopicsBtn" type="button">Delete</button>
            <button class="btn" id="cancelTopicSelectionBtn" type="button">Cancel</button>
          </div>
          <div id="topicList" class="topic-list"></div>
          <hr style="border-color:#30456f">
          <h3>Add Topic</h3>
          <div class="topic-input-wrap">
            <input id="topicName" class="topic-input" placeholder="e.g., Thermodynamics" />
            <button class="btn create-card-icon-btn topic-add-btn" id="addTopicBtn" type="button" aria-label="Add topic"
              title="Add topic" style="background-color: var(--success)">+</button>
          </div>
        </div>
      </section>

      <section class="panel" id="deckPanel">
        <div class="section" id="cardsOverviewSection">
          <!-- <div class="deck-sticky-stack"> -->
          <div class="controls deck-controls deck-header-tile">
            <button class="btn" id="backToTopicsBtn">‚Üê</button>
            <div class="deck-title-wrap">
              <h2 id="deckTitle" class="deck-title">Deck</h2>
              <div id="deckTopicCardCount" class="tiny deck-topic-card-count hidden"></div>
            </div>
            <div class="deck-actions">
              <button class="btn select-cards-btn" id="toggleCardSelectBtn" aria-label="Karten ausw√§hlen"
                title="Karten ausw√§hlen" type="button">
                <img src="icons/icons8-ha%CC%88kchen.svg" alt="" />
              </button>
              <button class="btn create-card-icon-btn" id="openCreateCardBtn" style="background-color: var(--success)"
                aria-label="Create flashcard" title="Create flashcard">+</button>
            </div>
            <!-- </div> -->
            <!-- <div class="tiny deck-separator-row">
              <separator class="card-tile-separator"></separator>
            </div> -->
            <div class="deck-bulk-actions hidden" id="deckBulkActions">
              <div class="tiny" id="deckSelectionCount">0 ausgew√§hlt</div>
              <button class="btn" id="moveSelectedCardsBtn" type="button">Verschieben</button>
              <button class="btn delete" id="deleteSelectedCardsBtn" type="button">L√∂schen</button>
              <button class="btn" id="cancelCardSelectionBtn" type="button">Abbrechen</button>
            </div>
          </div>
          <div id="cardsGrid" class="card-grid"></div>
        </div>

        <div class="section hidden" id="studySessionSection" style="height: 100%;">
          <div style="margin-inline: var(--space-4)">
            <div class="session-top">
              <button class="btn" id="backToTopicsBtnSession">‚Üê</button>
              <h3>Study Session</h3>
            </div>
            <div class="session-pill-bar">
              <div id="masteredPills" class="pill-row mastered"></div>
              <div id="activePills" class="pill-row active"></div>
            </div>
          </div>
          <div class="flash-area">
            <div id="flashcard" class="flashcard hidden">
              <div class="face" id="frontFace">
                <div class="card-corner-label">Question</div>
                <div class="study-topic-pill face-topic-pill hidden" id="frontTopicPill"></div>
                <button class="btn card-edit-btn" id="editSessionCardBtn">Edit</button>
                <div class="face-content" id="frontContent"></div>
              </div>
              <div class="face back" id="backFace">
                <div class="card-corner-label">Answer</div>
                <div class="study-topic-pill face-topic-pill hidden" id="backTopicPill"></div>
                <button class="btn card-edit-btn" id="editSessionCardBtnBack">Edit</button>
                <div class="face-content" id="backContent"></div>
              </div>
              <div class="swipe-glow" id="swipeGlow" aria-hidden="true"></div>
              <div class="swipe-badge" id="swipeBadge" aria-hidden="true"></div>
            </div>
          </div>
          <div class="controls">
            <button class="btn traffic green" data-grade="correct">Correct</button>
            <button class="btn traffic yellow" data-grade="partial">Not quite</button>
            <button class="btn traffic red" data-grade="wrong">Wrong</button>
          </div>
        </div>
      </section>

      <section class="panel" id="editorPanel">
        <div class="section editor-shell">
          <div class="controls" style="margin-bottom:10px; align-items:center; margin-inline: 0">
            <button class="btn" id="backToDeckBtn">‚Üê</button>
            <div>
              <h2 id="editorTitle" style="margin:0;">+</h2>
              <div class="tiny" id="editorSubtitle">Autosaved locally</div>
            </div>
            <button class="btn editor-sidebar-toggle" id="toggleEditorSidebarBtn">Cards</button>
          </div>
          <div id="editorOverlay" class="editor-overlay"></div>
          <div class="editor-grid">
            <div class="editor-list editor-sidebar" style="overflow: auto;">
              <div class="tiny">Existing cards</div>
              <div id="editorCardsList" class="editor-panel" style="display: block;"></div>
            </div>
            <div class="editor-separator" aria-hidden="true"></div>
            <div class="editor-panel editor-main">
              <div class="editor-main-scroll">
                <div class="editor-field">
                  <div class="field-head">
                    <label>Question</label>
                    <!-- <button class="btn btn-small formula-btn" data-formula-target="cardPrompt" type="button">Formula</button> -->
                  </div>
                  <div class="editor-input-media-row">
                    <textarea id="cardPrompt" placeholder="Type your question..."></textarea>
                    <div id="questionImagePreview" class="image-preview">Drop image here</div>
                  </div>
                  <div class="text-toolbar" data-group="create-question">
                    <div class="toolbar-segment">
                      <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                        data-group="create-question" data-align="left" aria-label="Align left"
                        title="Align left (Cmd/Ctrl+L)"><img src="icons/links.png" alt=""></button>
                      <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                        data-group="create-question" data-align="center" aria-label="Align center"
                        title="Align center (Cmd/Ctrl+C)"><img src="icons/center.png" alt=""></button>
                      <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                        data-group="create-question" data-align="justify" aria-label="Align justify"
                        title="Align justify (Cmd/Ctrl+J)"><img src="icons/rechts.png" alt=""></button>
                    </div>
                    <div class="toolbar-segment">
                      <button class="btn btn-small toolbar-btn" type="button" data-action="list"
                        data-target="cardPrompt" data-list="ul">‚Ä¢ List</button>
                      <button class="btn btn-small toolbar-btn" type="button" data-action="list"
                        data-target="cardPrompt" data-list="ol">1. List</button>
                      <button class="btn btn-small toolbar-btn" type="button" data-action="table"
                        data-target="cardPrompt">Table</button>
                    </div>
                  </div>
                  <div class="field-error hidden" id="questionError">Please fill in the question.</div>
                </div>
                <hr style="border-color:#30456f; width: 97%;">
                <!-- <div class="qa-editor-separator" aria-hidden="true"></div> -->
                <div class="editor-field" id="answerField">
                  <div class="mcq-primary-row" id="primaryAnswerRow">
                    <div class="mcq-primary-header hidden" id="primaryAnswerHeader">
                      <span class="mcq-badge correct" id="primaryAnswerBadge">Correct Answer ‚úì</span>
                      <label class="toggle mcq-toggle">
                        <input type="checkbox" id="primaryAnswerToggle" checked />
                        <span class="toggle-slider"></span>
                      </label>
                    </div>
                    <div class="field-head">
                      <label>Answer</label>
                      <!-- <button class="btn btn-small formula-btn" data-formula-target="cardAnswer" type="button">Formula</button> -->
                    </div>
                    <div class="editor-input-media-row">
                      <textarea id="cardAnswer" placeholder="Type the answer..."></textarea>
                      <div id="answerImagePreview" class="image-preview">Drop image here</div>
                    </div>
                    <div class="text-toolbar" data-group="create-answer">
                      <div class="toolbar-segment">
                        <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                          data-group="create-answer" data-align="left" aria-label="Align left"
                          title="Align left (Cmd/Ctrl+L)"><img src="icons/links.png" alt=""></button>
                        <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                          data-group="create-answer" data-align="center" aria-label="Align center"
                          title="Align center (Cmd/Ctrl+C)"><img src="icons/center.png" alt=""></button>
                        <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                          data-group="create-answer" data-align="justify" aria-label="Align justify"
                          title="Align justify (Cmd/Ctrl+J)"><img src="icons/rechts.png" alt=""></button>
                      </div>
                      <div class="toolbar-segment">
                        <button class="btn btn-small toolbar-btn" type="button" data-action="list"
                          data-target="cardAnswer" data-list="ul">‚Ä¢ List</button>
                        <button class="btn btn-small toolbar-btn" type="button" data-action="list"
                          data-target="cardAnswer" data-list="ol">1. List</button>
                        <button class="btn btn-small toolbar-btn" type="button" data-action="table"
                          data-target="cardAnswer">Table</button>
                      </div>
                    </div>
                  </div>
                  <div class="editor-options">
                    <div class="tiny">Multi-select answers (optional)</div>
                    <div class="text-toolbar hidden" id="createOptionsToolbar" data-group="create-options">
                      <div class="toolbar-segment">
                        <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                          data-group="create-options" data-align="left" aria-label="Options align left"
                          title="Options align left"><img src="icons/links.png" alt=""></button>
                        <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                          data-group="create-options" data-align="center" aria-label="Options align center"
                          title="Options align center"><img src="icons/center.png" alt=""></button>
                      </div>
                    </div>
                    <div id="mcqOptions" class="hidden"></div>
                    <button class="btn" id="addMcqOptionBtn">Add Answer</button>
                  </div>
                  <div class="field-error hidden" id="answerError">Please enter at least one answer.</div>
                </div>
              </div>
              <div class="editor-footer">
                <button class="btn" id="addCardBtn" style="width: 100%; background-color: #d42dba6e">Create
                  Flashcard</button>
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </main>

  <script>
    const API_BASE = '/api';
    const STORE_KEYS = {
      subjects: 'id',
      topics: 'id',
      cards: 'id',
      progress: 'cardId',
      cardbank: 'id'
    };
    let dbReady = false;
    let selectedSubject = null;
    let selectedTopic = null;
    let selectedTopicIds = new Set();
    let sessionSize = 15;
    let availableSessionCards = 0;
    let session = { active: false, activeQueue: [], mastered: [], counts: {}, gradeMap: {}, mode: 'default' };
    let editingCardId = null;
    let editingSubjectId = null;
    let mcqMode = false;
    let editMcqMode = false;
    let createQuestionTextAlign = 'center';
    let createAnswerTextAlign = 'center';
    let editQuestionTextAlign = 'center';
    let editAnswerTextAlign = 'center';
    let createOptionsTextAlign = 'left';
    let editOptionsTextAlign = 'left';
    let formulaTarget = null;
    let tableTarget = null;
    let tableBuilderState = {
      rows: 3,
      cols: 3,
      withHeader: true,
      header: [],
      body: [],
      headerAlign: [],
      bodyAlign: []
    };
    let tableBuilderSelection = null;
    let suppressFlashcardTapUntil = 0;
    let deckSelectionMode = false;
    let deckSelectedCardIds = new Set();
    let topicSelectionMode = false;
    let topicSelectedIds = new Set();
    const SESSION_FILTER_DEFAULT = Object.freeze({
      all: false,
      correct: false,
      wrong: false,
      partial: false,
      notAnswered: false
    });
    let sessionFilterState = { ...SESSION_FILTER_DEFAULT };
    let progressByCardId = new Map();
    let lastProgressForceRefreshAt = 0;
    let sessionRunState = {
      startedAt: 0,
      topicIds: [],
      cardIds: [],
      filters: { ...SESSION_FILTER_DEFAULT },
      mode: 'default'
    };
    let sessionRepeatState = {
      remaining: 0,
      size: 0,
      topicIds: [],
      cardIds: [],
      filters: { ...SESSION_FILTER_DEFAULT },
      mode: 'default'
    };
    const DAILY_REVIEW_DEFAULT_SIZE = 15;
    const DAILY_REVIEW_STATUS_FILTER_DEFAULT = Object.freeze({
      green: true,
      yellow: false,
      red: false
    });
    let dailyReviewState = {
      ready: false,
      yesterdayKey: '',
      cardsByTopicId: new Map(),
      topics: [],
      selectedTopicIds: new Set(),
      statusByCardId: new Map(),
      statusFilter: { ...DAILY_REVIEW_STATUS_FILTER_DEFAULT },
      totalCards: 0,
      size: 0
    };
    const KATEX_CSS_URL = 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css';
    const KATEX_JS_URL = 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js';
    const KATEX_AUTORENDER_URL = 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js';
    const KATEX_RENDER_OPTIONS = Object.freeze({
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true }
      ],
      throwOnError: false
    });
    let katexLoading = null;
    const scriptLoadCache = new Map();
    const API_STORE_CACHE_DEFAULT_TTL_MS = 5000;
    const API_STORE_CACHE_TTL_BY_STORE = Object.freeze({
      subjects: 15000,
      topics: 15000,
      cards: 30000,
      progress: 4000,
      cardbank: 30000
    });
    const API_QUERY_CACHE_DEFAULT_TTL_MS = 5000;
    const API_QUERY_CACHE_TTL_BY_ROUTE = Object.freeze({
      '/api/stats': 10000,
      '/api/topics': 60000,
      // Topic card payloads should stay cached until app data changes.
      '/api/cards': 86400000,
      '/api/progress': 4000
    });
    const apiStoreCache = new Map();
    const apiStoreInFlight = new Map();
    const apiQueryCache = new Map();
    const apiQueryInFlight = new Map();
    let topicDirectory = [];
    let topicDirectoryBySubject = new Map();
    let topicDirectoryById = new Map();
    let topicDirectoryReady = false;
    let topicPrefetchRunId = 0;

    const el = id => document.getElementById(id);

    function cloneData(value) {
      if (typeof structuredClone === 'function') return structuredClone(value);
      return JSON.parse(JSON.stringify(value));
    }

    function invalidateApiStoreCache(store = null) {
      if (store) {
        apiStoreCache.delete(store);
        apiStoreInFlight.delete(store);
        apiQueryCache.clear();
        apiQueryInFlight.clear();
        topicDirectory = [];
        topicDirectoryBySubject = new Map();
        topicDirectoryById = new Map();
        topicDirectoryReady = false;
        return;
      }
      apiStoreCache.clear();
      apiStoreInFlight.clear();
      apiQueryCache.clear();
      apiQueryInFlight.clear();
      topicDirectory = [];
      topicDirectoryBySubject = new Map();
      topicDirectoryById = new Map();
      topicDirectoryReady = false;
    }

    function setDeckTitle(title = 'Deck') {
      const titleEl = el('deckTitle');
      if (!titleEl) return;
      const text = String(title || 'Deck').trim() || 'Deck';
      titleEl.textContent = text;
      titleEl.classList.toggle('is-long', text.length > 22);
      titleEl.classList.toggle('is-very-long', text.length > 36);
      titleEl.setAttribute('title', text);
    }

    function setDeckTopicCardCount(count = null) {
      const countEl = el('deckTopicCardCount');
      if (!countEl) return;
      if (!Number.isFinite(count)) {
        countEl.textContent = '';
        countEl.classList.add('hidden');
        return;
      }
      const safeCount = Math.max(0, Math.trunc(count));
      countEl.textContent = `${safeCount} ${safeCount === 1 ? 'card' : 'cards'}`;
      countEl.classList.remove('hidden');
    }

    function normalizeSessionFilters(state = null) {
      const raw = (state && typeof state === 'object') ? state : SESSION_FILTER_DEFAULT;
      const normalized = {
        all: !!raw.all,
        correct: !!raw.correct,
        wrong: !!raw.wrong,
        partial: !!raw.partial,
        notAnswered: !!raw.notAnswered
      };
      if (normalized.all) {
        normalized.correct = false;
        normalized.wrong = false;
        normalized.partial = false;
        normalized.notAnswered = false;
      }
      return normalized;
    }

    function getTodayKey(date = new Date()) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function getDayKeyByOffset(offsetDays = 0, date = new Date()) {
      const base = new Date(date);
      base.setDate(base.getDate() + Math.trunc(Number(offsetDays) || 0));
      return getTodayKey(base);
    }

    function resetDailyReviewState() {
      dailyReviewState = {
        ready: false,
        yesterdayKey: getDayKeyByOffset(-1),
        cardsByTopicId: new Map(),
        topics: [],
        selectedTopicIds: new Set(),
        statusByCardId: new Map(),
        statusFilter: { ...DAILY_REVIEW_STATUS_FILTER_DEFAULT },
        totalCards: 0,
        size: 0
      };
    }

    function normalizeDayProgress(raw = null) {
      const src = (raw && typeof raw === 'object') ? raw : {};
      const dayLastGrade = typeof src.lastGrade === 'string' ? src.lastGrade : '';
      const correctStreakRaw = Number(src.correctStreak);
      const correctStreak = Number.isFinite(correctStreakRaw) ? Math.max(0, Math.trunc(correctStreakRaw)) : 0;
      const legacyMastered = Number(src.correct) >= 3 && dayLastGrade === 'correct';
      const explicitMastered = src.mastered === true && dayLastGrade === 'correct';
      const derivedStreak = correctStreak > 0
        ? correctStreak
        : legacyMastered
          ? 3
          : dayLastGrade === 'correct'
            ? 1
            : 0;
      return {
        correct: Number.isFinite(Number(src.correct)) ? Number(src.correct) : 0,
        wrong: Number.isFinite(Number(src.wrong)) ? Number(src.wrong) : 0,
        partial: Number.isFinite(Number(src.partial)) ? Number(src.partial) : 0,
        correctStreak: derivedStreak,
        mastered: explicitMastered || derivedStreak >= 3 || legacyMastered,
        lastGrade: dayLastGrade,
        lastAnsweredAt: typeof src.lastAnsweredAt === 'string' ? src.lastAnsweredAt : ''
      };
    }

    function normalizeProgressRecord(record, cardId) {
      const src = (record && typeof record === 'object') ? record : {};
      const byDay = {};
      if (src.byDay && typeof src.byDay === 'object') {
        Object.keys(src.byDay).forEach(dayKey => {
          byDay[dayKey] = normalizeDayProgress(src.byDay[dayKey]);
        });
      }
      const totalsSrc = (src.totals && typeof src.totals === 'object') ? src.totals : {};
      return {
        cardId,
        byDay,
        totals: {
          correct: Number.isFinite(Number(totalsSrc.correct)) ? Number(totalsSrc.correct) : 0,
          wrong: Number.isFinite(Number(totalsSrc.wrong)) ? Number(totalsSrc.wrong) : 0,
          partial: Number.isFinite(Number(totalsSrc.partial)) ? Number(totalsSrc.partial) : 0
        },
        lastGrade: typeof src.lastGrade === 'string' ? src.lastGrade : '',
        lastAnsweredAt: typeof src.lastAnsweredAt === 'string' ? src.lastAnsweredAt : ''
      };
    }

    async function getProgressByCardIds(cardIds, options = {}) {
      const ids = Array.isArray(cardIds)
        ? Array.from(new Set(cardIds.map(cardId => String(cardId || '').trim()).filter(Boolean)))
        : [];
      if (!ids.length) return [];
      ids.sort();
      const opts = options && typeof options === 'object' ? options : {};
      const baseParams = new URLSearchParams();
      ids.forEach(cardId => baseParams.append('cardId', cardId));
      const baseQueryPath = `${API_BASE}/progress?${baseParams.toString()}`;
      const requestParams = new URLSearchParams(baseParams.toString());
      const payloadLabel = String(opts.payloadLabel || '').trim();
      if (payloadLabel) requestParams.set('payload', payloadLabel);
      const requestPath = `${API_BASE}/progress?${requestParams.toString()}`;
      const data = await getCachedApiQuery(requestPath, { ...opts, cacheKey: baseQueryPath });
      const rows = Array.isArray(data) ? data : [];
      const wantedIds = new Set(ids);
      return rows.filter(row => wantedIds.has(String(row?.cardId || '').trim()));
    }

    async function ensureProgressForCardIds(cardIds, options = {}) {
      const ids = Array.isArray(cardIds)
        ? Array.from(new Set(cardIds.map(cardId => String(cardId || '').trim()).filter(Boolean)))
        : [];
      if (!ids.length) return;
      const opts = options && typeof options === 'object' ? options : {};
      const force = !!opts.force;
      const toLoad = force ? ids : ids.filter(cardId => !progressByCardId.has(cardId));
      if (!toLoad.length) return;
      const records = await getProgressByCardIds(toLoad, opts);
      const loaded = new Set();
      records.forEach(record => {
        const key = String(record?.cardId || '').trim();
        if (!key) return;
        progressByCardId.set(key, normalizeProgressRecord(record, key));
        loaded.add(key);
      });
      toLoad.forEach(cardId => {
        if (loaded.has(cardId)) return;
        progressByCardId.set(cardId, normalizeProgressRecord(null, cardId));
      });
    }

    function getCardDayProgress(cardId, dayKey = getTodayKey()) {
      const record = progressByCardId.get(cardId);
      return normalizeDayProgress(record?.byDay?.[dayKey]);
    }

    async function recordCardProgress(cardId, grade, options = {}) {
      if (!cardId) return;
      if (!['correct', 'wrong', 'partial'].includes(grade)) return;
      const opts = options && typeof options === 'object' ? options : {};
      const masteryTargetRaw = Number(opts.masteryTarget);
      const masteryTarget = Number.isFinite(masteryTargetRaw)
        ? Math.max(1, Math.trunc(masteryTargetRaw))
        : 3;
      await ensureProgressForCardIds([cardId], { payloadLabel: 'progress-update' });
      const nowIso = new Date().toISOString();
      const todayKey = getTodayKey();
      const record = normalizeProgressRecord(progressByCardId.get(cardId), cardId);
      const day = normalizeDayProgress(record.byDay[todayKey]);
      day[grade] += 1;
      if (grade === 'correct') {
        day.correctStreak += 1;
        day.mastered = day.correctStreak >= masteryTarget;
      } else {
        day.correctStreak = 0;
        day.mastered = false;
      }
      day.lastGrade = grade;
      day.lastAnsweredAt = nowIso;
      record.byDay[todayKey] = day;
      record.totals[grade] += 1;
      record.lastGrade = grade;
      record.lastAnsweredAt = nowIso;
      await put('progress', record);
      progressByCardId.set(cardId, record);
    }

    function cardMatchesSessionFilter(cardId, filters = sessionFilterState, dayKey = getTodayKey()) {
      const config = normalizeSessionFilters(filters);
      const day = getCardDayProgress(cardId, dayKey);
      const record = progressByCardId.get(cardId);
      const answeredToday = (day.correct + day.wrong + day.partial) > 0;
      let lastGradeToday = typeof day.lastGrade === 'string' ? day.lastGrade : '';
      if (!lastGradeToday && answeredToday) {
        const recordLastGrade = typeof record?.lastGrade === 'string' ? record.lastGrade : '';
        const recordDayKey = typeof record?.lastAnsweredAt === 'string' ? record.lastAnsweredAt.slice(0, 10) : '';
        if (recordLastGrade && recordDayKey === dayKey) lastGradeToday = recordLastGrade;
      }
      const masteredToday = day.mastered === true
        || day.correctStreak >= 3
        || (day.correct >= 3 && lastGradeToday === 'correct');
      const state = !answeredToday
        ? 'notAnswered'
        : masteredToday
          ? 'correct'
          : lastGradeToday === 'wrong'
            ? 'wrong'
            : 'partial';
      if (config.all) {
        return state !== 'correct';
      }
      const hasSpecificFilter = config.correct || config.wrong || config.partial || config.notAnswered;
      if (!hasSpecificFilter) {
        return true;
      }
      const matchCorrect = config.correct && state === 'correct';
      const matchWrong = config.wrong && state === 'wrong';
      const matchPartial = config.partial && state === 'partial';
      const matchNotAnswered = config.notAnswered && state === 'notAnswered';
      return matchCorrect || matchWrong || matchPartial || matchNotAnswered;
    }

    async function ensureSessionProgressForCards(cards = [], payloadLabel = 'session-progress') {
      const cardList = Array.isArray(cards) ? cards : [];
      if (!cardList.length) return;
      const now = Date.now();
      const shouldForceProgressRefresh = now - lastProgressForceRefreshAt >= 5000;
      await ensureProgressForCardIds(
        cardList.map(card => card.id),
        { force: shouldForceProgressRefresh, payloadLabel }
      );
      if (shouldForceProgressRefresh) lastProgressForceRefreshAt = now;
    }

    async function getEligibleSessionCardsByTopicIds(topicIds, filters = sessionFilterState) {
      if (!Array.isArray(topicIds) || !topicIds.length) return [];
      const cards = await getCardsByTopicIds(topicIds);
      if (!cards.length) return [];
      await ensureSessionProgressForCards(cards, 'session-progress');
      return cards.filter(card => cardMatchesSessionFilter(card.id, filters));
    }

    async function getEligibleSessionCardsByCardIds(cardIds, filters = sessionFilterState, options = {}) {
      const ids = Array.isArray(cardIds)
        ? Array.from(new Set(cardIds.map(cardId => String(cardId || '').trim()).filter(Boolean)))
        : [];
      if (!ids.length) return [];
      const opts = options && typeof options === 'object' ? options : {};
      const cards = await getCardsByCardIds(ids, opts);
      if (!cards.length) return [];
      await ensureSessionProgressForCards(cards, 'session-progress');
      return cards.filter(card => cardMatchesSessionFilter(card.id, filters));
    }

    function getSessionFilterSummaryText(filters = sessionFilterState) {
      const config = normalizeSessionFilters(filters);
      if (config.all) {
        return 'Filter: All remaining cards (excluding cards mastered today: 3x correct in a row).';
      }
      const hasSpecificFilter = config.correct || config.wrong || config.partial || config.notAnswered;
      if (!hasSpecificFilter) {
        return 'Filter: None (all cards in selected topics).';
      }
      const labels = [];
      if (config.correct) labels.push('Correctly answered (mastered)');
      if (config.wrong) labels.push('Wrong');
      if (config.partial) labels.push('Not quite / In progress');
      if (config.notAnswered) labels.push('Not answered today');
      return `Filter: ${labels.join(', ')}`;
    }

    function renderSessionFilterSummary() {
      const summary = el('sessionFilterSummary');
      if (!summary) return;
      summary.textContent = getSessionFilterSummaryText(sessionFilterState);
    }

    async function setSessionFilterState(nextState, options = {}) {
      const { refresh = true } = options;
      sessionFilterState = normalizeSessionFilters(nextState);
      renderSessionFilterSummary();
      if (refresh && selectedSubject) {
        await refreshTopicSessionMeta();
      }
    }

    function syncSessionFilterDialogControls() {
      const all = el('sessionFilterAll');
      const correct = el('sessionFilterCorrect');
      const wrong = el('sessionFilterWrong');
      const partial = el('sessionFilterPartial');
      const notAnswered = el('sessionFilterNotAnswered');
      if (!all || !correct || !wrong || !partial || !notAnswered) return;
      const locked = all.checked;
      correct.disabled = locked;
      wrong.disabled = locked;
      partial.disabled = locked;
      notAnswered.disabled = locked;
    }

    function fillSessionFilterDialogFromState() {
      const config = normalizeSessionFilters(sessionFilterState);
      const all = el('sessionFilterAll');
      const correct = el('sessionFilterCorrect');
      const wrong = el('sessionFilterWrong');
      const partial = el('sessionFilterPartial');
      const notAnswered = el('sessionFilterNotAnswered');
      if (!all || !correct || !wrong || !partial || !notAnswered) return;
      all.checked = config.all;
      correct.checked = config.correct;
      wrong.checked = config.wrong;
      partial.checked = config.partial;
      notAnswered.checked = config.notAnswered;
      syncSessionFilterDialogControls();
    }

    function pullSessionFiltersFromDialog() {
      const all = el('sessionFilterAll');
      const correct = el('sessionFilterCorrect');
      const wrong = el('sessionFilterWrong');
      const partial = el('sessionFilterPartial');
      const notAnswered = el('sessionFilterNotAnswered');
      if (!all || !correct || !wrong || !partial || !notAnswered) return normalizeSessionFilters(sessionFilterState);
      return normalizeSessionFilters({
        all: all.checked,
        correct: correct.checked,
        wrong: wrong.checked,
        partial: partial.checked,
        notAnswered: notAnswered.checked
      });
    }

    function isDayMastered(day) {
      const safeDay = normalizeDayProgress(day);
      const attempts = Number(safeDay.correct || 0) + Number(safeDay.wrong || 0) + Number(safeDay.partial || 0);
      if (attempts <= 0) return false;
      if (safeDay.lastGrade !== 'correct') return false;
      // Normal mastery requires 3 correct in a row (and at least 3 correct answers on that day).
      const streakMastered = safeDay.correctStreak >= 3 && Number(safeDay.correct || 0) >= 3;
      // Review-mode mastery can legitimately be 1x correct if the card was persisted as mastered.
      const reviewMastered = safeDay.mastered === true && Number(safeDay.correct || 0) >= 1;
      return streakMastered || reviewMastered;
    }

    function normalizeDailyReviewStatusFilter(state = null) {
      const raw = (state && typeof state === 'object') ? state : DAILY_REVIEW_STATUS_FILTER_DEFAULT;
      return {
        green: !!raw.green,
        yellow: !!raw.yellow,
        red: !!raw.red
      };
    }

    function getDailyReviewCardStatus(cardId) {
      const key = String(cardId || '').trim();
      if (!key) return '';
      return String(dailyReviewState.statusByCardId.get(key) || '');
    }

    function cardMatchesDailyReviewStatus(cardId, statusFilter = dailyReviewState.statusFilter) {
      const status = getDailyReviewCardStatus(cardId);
      if (!status) return false;
      const filter = normalizeDailyReviewStatusFilter(statusFilter);
      if (!filter.green && !filter.yellow && !filter.red) return false;
      return status === 'green'
        ? filter.green
        : status === 'yellow'
          ? filter.yellow
          : status === 'red'
            ? filter.red
            : false;
    }

    function getDailyReviewFilterSummaryText(filter = dailyReviewState.statusFilter) {
      const statusFilter = normalizeDailyReviewStatusFilter(filter);
      const labels = [];
      if (statusFilter.green) labels.push('Green');
      if (statusFilter.yellow) labels.push('Yellow');
      if (statusFilter.red) labels.push('Red');
      if (!labels.length) return 'Status: None selected';
      return `Status: ${labels.join(', ')}`;
    }

    function renderDailyReviewFilterSummary() {
      const metaEl = el('dailyReviewFilterMeta');
      if (!metaEl) return;
      metaEl.textContent = getDailyReviewFilterSummaryText();
    }

    function pullDailyReviewStatusFilterFromControls() {
      const green = el('dailyReviewFilterGreen');
      const yellow = el('dailyReviewFilterYellow');
      const red = el('dailyReviewFilterRed');
      return normalizeDailyReviewStatusFilter({
        green: !!green?.checked,
        yellow: !!yellow?.checked,
        red: !!red?.checked
      });
    }

    function fillDailyReviewStatusFilterControls() {
      const filter = normalizeDailyReviewStatusFilter(dailyReviewState.statusFilter);
      const green = el('dailyReviewFilterGreen');
      const yellow = el('dailyReviewFilterYellow');
      const red = el('dailyReviewFilterRed');
      if (green) green.checked = filter.green;
      if (yellow) yellow.checked = filter.yellow;
      if (red) red.checked = filter.red;
    }

    function getDailyReviewFilteredCardIdsByTopic(topicId) {
      const key = String(topicId || '').trim();
      if (!key) return [];
      const cardIds = dailyReviewState.cardsByTopicId.get(key) || [];
      return cardIds.filter(cardId => cardMatchesDailyReviewStatus(cardId));
    }

    function getDailyReviewSelectedCardIds() {
      if (!dailyReviewState.ready) return [];
      const selected = dailyReviewState.selectedTopicIds;
      const seen = new Set();
      const ids = [];
      dailyReviewState.topics.forEach(topic => {
        if (!selected.has(topic.topicId)) return;
        const cardIds = getDailyReviewFilteredCardIdsByTopic(topic.topicId);
        cardIds.forEach(cardId => {
          if (seen.has(cardId)) return;
          seen.add(cardId);
          ids.push(cardId);
        });
      });
      return ids;
    }

    function updateDailyReviewSizeCounter() {
      const selectedCardIds = getDailyReviewSelectedCardIds();
      const available = selectedCardIds.length;
      if (available <= 0) {
        dailyReviewState.size = 0;
      } else if (dailyReviewState.size <= 0) {
        dailyReviewState.size = Math.min(DAILY_REVIEW_DEFAULT_SIZE, available);
      } else {
        dailyReviewState.size = Math.min(dailyReviewState.size, available);
      }

      const valueEl = el('dailyReviewSizeValue');
      const minusBtn = el('dailyReviewMinus');
      const plusBtn = el('dailyReviewPlus');
      const startBtn = el('startDailyReviewBtn');
      const selectedMetaEl = el('dailyReviewSelectionMeta');
      if (valueEl) {
        const current = available > 0 ? dailyReviewState.size : 0;
        valueEl.textContent = `${current} / ${available}`;
      }
      if (minusBtn) minusBtn.disabled = available <= 0 || dailyReviewState.size <= 1;
      if (plusBtn) plusBtn.disabled = available <= 0 || dailyReviewState.size >= available;
      if (startBtn) startBtn.disabled = available <= 0;
      if (selectedMetaEl) {
        const selectedTopics = dailyReviewState.topics.filter(topic => (
          dailyReviewState.selectedTopicIds.has(topic.topicId)
          && getDailyReviewFilteredCardIdsByTopic(topic.topicId).length > 0
        )).length;
        const topicWord = selectedTopics === 1 ? 'topic' : 'topics';
        const cardWord = available === 1 ? 'card' : 'cards';
        selectedMetaEl.textContent = `${selectedTopics} ${topicWord} selected ‚Ä¢ ${available} ${cardWord}`;
      }
    }

    function renderDailyReviewTopicList() {
      const listEl = el('dailyReviewTopicList');
      if (!listEl) return;
      listEl.innerHTML = '';

      if (!dailyReviewState.ready || !dailyReviewState.topics.length) {
        listEl.innerHTML = '<div class="tiny">No answered cards available for review yet.</div>';
        updateDailyReviewSizeCounter();
        return;
      }

      dailyReviewState.topics.forEach(topic => {
        const filteredCardIds = getDailyReviewFilteredCardIdsByTopic(topic.topicId);
        const availableCount = filteredCardIds.length;
        const option = document.createElement('label');
        option.className = 'session-filter-option daily-review-topic-option';
        if (availableCount <= 0) option.classList.add('is-disabled');

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.disabled = availableCount <= 0;
        checkbox.checked = availableCount > 0 && dailyReviewState.selectedTopicIds.has(topic.topicId);
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) dailyReviewState.selectedTopicIds.add(topic.topicId);
          else dailyReviewState.selectedTopicIds.delete(topic.topicId);
          updateDailyReviewSizeCounter();
        });

        const textWrap = document.createElement('div');
        textWrap.className = 'daily-review-topic-text';
        const nameEl = document.createElement('div');
        nameEl.className = 'daily-review-topic-name';
        nameEl.textContent = topic.topicName;
        const metaEl = document.createElement('div');
        metaEl.className = 'tiny';
        const countWord = availableCount === 1 ? 'card' : 'cards';
        metaEl.textContent = `${topic.subjectName} ‚Ä¢ ${availableCount} / ${topic.count} ${countWord}`;
        textWrap.append(nameEl, metaEl);

        option.append(checkbox, textWrap);
        listEl.appendChild(option);
      });

      updateDailyReviewSizeCounter();
    }

    function renderDailyReviewPanelSummary() {
      const messageEl = el('dailyReviewMessage');
      const cardsEl = el('dailyReviewTotalCards');
      const topicsEl = el('dailyReviewTotalTopics');
      const cardWord = dailyReviewState.totalCards === 1 ? 'card' : 'cards';
      const topicWord = dailyReviewState.topics.length === 1 ? 'topic' : 'topics';
      if (messageEl) {
        messageEl.textContent = `You have ${dailyReviewState.totalCards} answered ${cardWord}. Select status and topics for review.`;
      }
      if (cardsEl) cardsEl.textContent = String(dailyReviewState.totalCards);
      if (topicsEl) topicsEl.textContent = String(dailyReviewState.topics.length);
      fillDailyReviewStatusFilterControls();
      renderDailyReviewFilterSummary();
      renderDailyReviewTopicList();
    }

    async function prepareDailyReviewState() {
      resetDailyReviewState();
      const yesterdayKey = getDayKeyByOffset(-1);
      const progressRecords = await getAll('progress');
      if (!Array.isArray(progressRecords) || !progressRecords.length) {
        return false;
      }

      const answeredCardIds = [];
      const statusByCardId = new Map();
      progressRecords.forEach(row => {
        const cardId = String(row?.cardId || '').trim();
        if (!cardId) return;
        const state = getCurrentProgressState(row, cardId);
        if (state.attemptsTotal <= 0) return;
        let status = '';
        if (state.key === 'mastered' || state.key === 'correct') {
          status = 'green';
        } else if (state.key === 'partial' || state.key === 'in-progress') {
          status = 'yellow';
        } else if (state.key === 'wrong') {
          status = 'red';
        }
        if (!status) return;
        statusByCardId.set(cardId, status);
        answeredCardIds.push(cardId);
      });

      const uniqueCardIds = Array.from(new Set(answeredCardIds));
      if (!uniqueCardIds.length) return false;

      await preloadTopicDirectory();
      const cards = await getCardsByCardIds(uniqueCardIds, { payloadLabel: 'daily-review-candidates' });
      if (!cards.length) return false;

      const subjects = await getAll('subjects');
      const subjectNameById = new Map(
        subjects.map(subject => [String(subject?.id || '').trim(), String(subject?.name || 'Unknown subject').trim() || 'Unknown subject'])
      );
      const cardsByTopicId = new Map();
      cards.forEach(card => {
        const cardId = String(card?.id || '').trim();
        const topicId = String(card?.topicId || '').trim();
        if (!cardId || !topicId || !statusByCardId.has(cardId)) return;
        if (!cardsByTopicId.has(topicId)) cardsByTopicId.set(topicId, []);
        cardsByTopicId.get(topicId).push(cardId);
      });
      if (!cardsByTopicId.size) return false;

      const topics = Array.from(cardsByTopicId.entries()).map(([topicId, cardIds]) => {
        const topic = topicDirectoryById.get(topicId) || {};
        const subjectId = String(topic?.subjectId || '').trim();
        const topicName = String(topic?.name || '').trim() || 'Unknown topic';
        const subjectName = subjectNameById.get(subjectId) || 'Unknown subject';
        return {
          topicId,
          topicName,
          subjectName,
          count: cardIds.length
        };
      });
      topics.sort((a, b) => {
        const subjectDiff = a.subjectName.localeCompare(b.subjectName);
        if (subjectDiff !== 0) return subjectDiff;
        return a.topicName.localeCompare(b.topicName);
      });

      const selectedTopicIds = new Set(topics.map(topic => topic.topicId));
      const totalCards = topics.reduce((sum, topic) => sum + topic.count, 0);
      dailyReviewState = {
        ready: topics.length > 0 && totalCards > 0,
        yesterdayKey,
        cardsByTopicId,
        topics,
        selectedTopicIds,
        statusByCardId,
        statusFilter: { ...DAILY_REVIEW_STATUS_FILTER_DEFAULT },
        totalCards,
        size: totalCards > 0 ? Math.min(DAILY_REVIEW_DEFAULT_SIZE, totalCards) : 0
      };
      return dailyReviewState.ready;
    }

    async function refreshDailyReviewHomePanel(options = {}) {
      const panel = el('dailyReviewHomePanel');
      if (!panel) return;
      const opts = options && typeof options === 'object' ? options : {};
      const shouldReuseExisting = !!opts.useExisting && dailyReviewState.ready;
      if (!shouldReuseExisting) {
        const ready = await prepareDailyReviewState();
        panel.classList.toggle('hidden', !ready);
        if (!ready) return;
      } else {
        panel.classList.remove('hidden');
      }
      renderDailyReviewPanelSummary();
    }

    async function startDailyReviewFromHomePanel() {
      if (!dailyReviewState.ready) return;
      const topicIds = dailyReviewState.topics
        .filter(topic => dailyReviewState.selectedTopicIds.has(topic.topicId))
        .map(topic => topic.topicId);
      if (!topicIds.length) {
        alert('Select at least one topic.');
        return;
      }
      const cardIds = getDailyReviewSelectedCardIds();
      if (!cardIds.length) {
        alert('No review cards match the selected topics/status filter.');
        return;
      }
      const forcedSize = Math.min(Math.max(dailyReviewState.size, 1), cardIds.length);
      await startSession({
        topicIds,
        cardIds,
        filters: { ...SESSION_FILTER_DEFAULT, all: true },
        forcedSize,
        reviewMode: true
      });
    }

    function toCounterInt(value) {
      const num = Number(value);
      return Number.isFinite(num) ? Math.max(0, Math.trunc(num)) : 0;
    }

    function formatProgressTimestamp(iso = '') {
      const raw = String(iso || '').trim();
      if (!raw) return '‚Äî';
      const dt = new Date(raw);
      if (!Number.isFinite(dt.getTime())) return '‚Äî';
      return dt.toLocaleString();
    }

    function getQuestionPreviewText(card) {
      const raw = String(card?.prompt || '');
      let text = '';
      if (raw.trim()) {
        const parser = document.createElement('div');
        parser.innerHTML = markdownToHtml(raw);
        text = String(parser.textContent || '').replace(/\s+/g, ' ').trim();
      }
      if (!text && getCardImageList(card, 'Q').length > 0) {
        text = '[Image question]';
      }
      if (!text) text = '(empty)';
      if (text.length > 140) text = `${text.slice(0, 137)}...`;
      return text;
    }

    function getLatestProgressDayEntry(record, fallbackCardId = '') {
      const safeRecord = normalizeProgressRecord(record, String(record?.cardId || fallbackCardId || ''));
      const entries = Object.entries(safeRecord.byDay || {})
        .map(([dayKey, rawDay]) => {
          const day = normalizeDayProgress(rawDay);
          const attempts = toCounterInt(day.correct) + toCounterInt(day.wrong) + toCounterInt(day.partial);
          if (attempts <= 0) return null;
          const parsedTs = Date.parse(String(day.lastAnsweredAt || ''));
          const ts = Number.isFinite(parsedTs) ? parsedTs : Date.parse(`${dayKey}T23:59:59`);
          return { dayKey, day, ts: Number.isFinite(ts) ? ts : 0 };
        })
        .filter(Boolean);
      if (!entries.length) return null;
      entries.sort((a, b) => b.ts - a.ts || b.dayKey.localeCompare(a.dayKey));
      return entries[0];
    }

    function getCurrentProgressState(record, fallbackCardId = '') {
      const safeRecord = normalizeProgressRecord(record, String(record?.cardId || fallbackCardId || ''));
      const totals = {
        correct: toCounterInt(safeRecord.totals?.correct),
        partial: toCounterInt(safeRecord.totals?.partial),
        wrong: toCounterInt(safeRecord.totals?.wrong)
      };
      const attemptsTotal = totals.correct + totals.partial + totals.wrong;
      if (attemptsTotal <= 0) {
        return {
          key: 'not-answered',
          label: 'Not answered',
          streak: 0,
          lastGrade: '‚Äî',
          lastAnsweredAt: '‚Äî',
          attemptsTotal,
          totals
        };
      }

      const latest = getLatestProgressDayEntry(safeRecord, fallbackCardId);
      const day = latest?.day || normalizeDayProgress(null);
      const lastGradeRaw = String(day.lastGrade || safeRecord.lastGrade || '').trim();
      const streak = toCounterInt(day.correctStreak);
      let key = 'in-progress';
      let label = 'In progress';
      if (lastGradeRaw === 'correct' && (day.mastered || streak >= 3)) {
        key = 'mastered';
        label = 'Mastered';
      } else if (lastGradeRaw === 'correct') {
        key = 'correct';
        label = 'Correct';
      } else if (lastGradeRaw === 'partial') {
        key = 'partial';
        label = 'Not quite';
      } else if (lastGradeRaw === 'wrong') {
        key = 'wrong';
        label = 'Wrong';
      }

      const lastGrade = lastGradeRaw
        ? (lastGradeRaw === 'partial' ? 'Not quite' : `${lastGradeRaw.charAt(0).toUpperCase()}${lastGradeRaw.slice(1)}`)
        : '‚Äî';
      const lastAnsweredAt = formatProgressTimestamp(day.lastAnsweredAt || safeRecord.lastAnsweredAt || '');
      return { key, label, streak, lastGrade, lastAnsweredAt, attemptsTotal, totals };
    }

    function getProgressHistoryLines(record, fallbackCardId = '', limit = 8) {
      const safeRecord = normalizeProgressRecord(record, String(record?.cardId || fallbackCardId || ''));
      const entries = Object.entries(safeRecord.byDay || {})
        .map(([dayKey, rawDay]) => {
          const day = normalizeDayProgress(rawDay);
          const attempts = toCounterInt(day.correct) + toCounterInt(day.wrong) + toCounterInt(day.partial);
          if (attempts <= 0) return null;
          const parsedTs = Date.parse(String(day.lastAnsweredAt || ''));
          const ts = Number.isFinite(parsedTs) ? parsedTs : Date.parse(`${dayKey}T23:59:59`);
          return {
            dayKey,
            day,
            ts: Number.isFinite(ts) ? ts : 0
          };
        })
        .filter(Boolean);
      if (!entries.length) return '‚Äî';
      entries.sort((a, b) => b.ts - a.ts || b.dayKey.localeCompare(a.dayKey));

      const shown = entries.slice(0, Math.max(1, toCounterInt(limit)));
      const lines = shown.map(({ dayKey, day }) => {
        const correct = toCounterInt(day.correct);
        const partial = toCounterInt(day.partial);
        const wrong = toCounterInt(day.wrong);
        const streak = toCounterInt(day.correctStreak);
        const masteredFlag = day.mastered || streak >= 3 ? ' M' : '';
        return `${dayKey}: C${correct}/P${partial}/W${wrong} ¬∑ S${streak}${masteredFlag}`;
      });
      if (entries.length > shown.length) {
        lines.push(`+${entries.length - shown.length} more`);
      }
      return lines.join('\n');
    }

    function buildProgressStateChip(state) {
      const chip = document.createElement('span');
      chip.className = `progress-state-chip progress-state-${state.key || 'in-progress'}`;
      chip.textContent = state.label || 'In progress';
      return chip;
    }

    async function renderProgressCheckTable() {
      const meta = el('progressCheckMeta');
      const body = el('progressCheckTableBody');
      if (!meta || !body) return;
      meta.textContent = 'Loading...';
      body.innerHTML = '<tr><td colspan="9" class="tiny">Loading...</td></tr>';

      const [subjects, topics, cards, progressRows] = await Promise.all([
        getAll('subjects'),
        getAll('topics'),
        getAll('cards'),
        getAll('progress')
      ]);
      const subjectById = new Map(
        (subjects || []).map(subject => [String(subject?.id || '').trim(), String(subject?.name || '').trim()])
      );
      const topicById = new Map(
        (topics || []).map(topic => [String(topic?.id || '').trim(), topic])
      );
      const progressByCardId = new Map(
        (progressRows || []).map(row => [String(row?.cardId || '').trim(), row])
      );

      const cardRows = Array.isArray(cards) ? [...cards] : [];
      cardRows.sort((a, b) => {
        const topicA = topicById.get(String(a?.topicId || '').trim()) || {};
        const topicB = topicById.get(String(b?.topicId || '').trim()) || {};
        const subjectA = String(subjectById.get(String(topicA?.subjectId || '').trim()) || 'Unknown subject');
        const subjectB = String(subjectById.get(String(topicB?.subjectId || '').trim()) || 'Unknown subject');
        const subjectCmp = subjectA.localeCompare(subjectB);
        if (subjectCmp !== 0) return subjectCmp;
        const topicCmp = String(topicA?.name || 'Unknown topic').localeCompare(String(topicB?.name || 'Unknown topic'));
        if (topicCmp !== 0) return topicCmp;
        return getCardCreatedAt(b) - getCardCreatedAt(a);
      });

      body.innerHTML = '';
      if (!cardRows.length) {
        body.innerHTML = '<tr><td colspan="9" class="tiny">No cards available.</td></tr>';
        meta.textContent = '0 cards';
        return;
      }

      let answeredCount = 0;
      let masteredCount = 0;
      cardRows.forEach(card => {
        const cardId = String(card?.id || '').trim();
        const topic = topicById.get(String(card?.topicId || '').trim()) || {};
        const subjectName = String(subjectById.get(String(topic?.subjectId || '').trim()) || 'Unknown subject');
        const topicName = String(topic?.name || 'Unknown topic');
        const record = progressByCardId.get(cardId) || null;
        const current = getCurrentProgressState(record, cardId);
        const history = getProgressHistoryLines(record, cardId);
        if (current.attemptsTotal > 0) answeredCount += 1;
        if (current.key === 'mastered') masteredCount += 1;

        const tr = document.createElement('tr');
        const questionCell = document.createElement('td');
        questionCell.className = 'progress-question-cell';
        questionCell.textContent = getQuestionPreviewText(card);

        const currentCell = document.createElement('td');
        currentCell.className = 'progress-current-cell';
        currentCell.appendChild(buildProgressStateChip(current));

        const historyCell = document.createElement('td');
        historyCell.className = 'progress-history-cell';
        historyCell.textContent = history;

        const totalsCell = document.createElement('td');
        totalsCell.textContent = `${current.totals.correct}/${current.totals.partial}/${current.totals.wrong}`;

        const streakCell = document.createElement('td');
        streakCell.textContent = String(current.streak);

        const lastGradeCell = document.createElement('td');
        lastGradeCell.textContent = current.lastGrade;

        const lastAnsweredCell = document.createElement('td');
        lastAnsweredCell.textContent = current.lastAnsweredAt;

        const subjectCell = document.createElement('td');
        subjectCell.textContent = subjectName;
        const topicCell = document.createElement('td');
        topicCell.textContent = topicName;

        tr.append(
          subjectCell,
          topicCell,
          questionCell,
          currentCell,
          streakCell,
          lastGradeCell,
          lastAnsweredCell,
          totalsCell,
          historyCell
        );
        body.appendChild(tr);
      });

      const cardWord = cardRows.length === 1 ? 'card' : 'cards';
      meta.textContent = `${cardRows.length} ${cardWord} ‚Ä¢ ${answeredCount} answered ‚Ä¢ ${masteredCount} mastered`;
    }

    async function openProgressCheckDialog() {
      const dialog = el('progressCheckDialog');
      if (!dialog) return;
      await renderProgressCheckTable();
      showDialog(dialog);
    }

    function formatDurationLabel(ms) {
      const totalSeconds = Math.max(0, Math.round(ms / 1000));
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      if (hours > 0) {
        return `${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      }
      return `${minutes}:${String(seconds).padStart(2, '0')}`;
    }

    function updateSessionRepeatCounter() {
      const valueEl = el('sessionRepeatSizeValue');
      const minusBtn = el('sessionRepeatMinus');
      const plusBtn = el('sessionRepeatPlus');
      const startBtn = el('startAnotherSessionBtn');
      if (valueEl) {
        const current = sessionRepeatState.remaining > 0 ? sessionRepeatState.size : 0;
        valueEl.textContent = `${current} / ${sessionRepeatState.remaining}`;
      }
      if (minusBtn) minusBtn.disabled = sessionRepeatState.remaining <= 0 || sessionRepeatState.size <= 1;
      if (plusBtn) plusBtn.disabled = sessionRepeatState.remaining <= 0 || sessionRepeatState.size >= sessionRepeatState.remaining;
      if (startBtn) startBtn.disabled = sessionRepeatState.remaining <= 0;
    }

    async function openSessionCompleteDialog() {
      const topicIds = sessionRunState.topicIds.length
        ? [...sessionRunState.topicIds]
        : Array.from(selectedTopicIds);
      const scopedCardIds = Array.isArray(sessionRunState.cardIds) ? [...sessionRunState.cardIds] : [];
      const remainingCards = scopedCardIds.length
        ? await getEligibleSessionCardsByCardIds(scopedCardIds, sessionRunState.filters, { payloadLabel: 'session-repeat' })
        : await getEligibleSessionCardsByTopicIds(topicIds, sessionRunState.filters);
      const durationMs = sessionRunState.startedAt > 0 ? Date.now() - sessionRunState.startedAt : 0;
      sessionRepeatState.topicIds = topicIds;
      sessionRepeatState.cardIds = scopedCardIds;
      sessionRepeatState.filters = normalizeSessionFilters(sessionRunState.filters);
      sessionRepeatState.mode = sessionRunState.mode || 'default';
      sessionRepeatState.remaining = remainingCards.length;
      sessionRepeatState.size = remainingCards.length > 0
        ? Math.min(Math.max(sessionSize, 1), remainingCards.length)
        : 0;

      const durationEl = el('sessionCompleteDuration');
      if (durationEl) durationEl.textContent = formatDurationLabel(durationMs);
      const remainingEl = el('sessionCompleteRemaining');
      if (remainingEl) remainingEl.textContent = String(sessionRepeatState.remaining);
      const messageEl = el('sessionCompleteMessage');
      if (messageEl) {
        if (sessionRepeatState.remaining > 0) {
          messageEl.textContent = 'Great work! You can continue with the remaining cards.';
        } else {
          messageEl.textContent = 'Great work! No remaining cards match the current filter.';
        }
      }
      updateSessionRepeatCounter();
      showDialog(el('sessionCompleteDialog'));
    }

    async function apiRequest(path, options = {}) {
      const init = { ...options };
      if (init.body && !init.headers) init.headers = { 'Content-Type': 'application/json' };
      if (init.body && init.headers && !init.headers['Content-Type']) {
        init.headers['Content-Type'] = 'application/json';
      }
      const res = await fetch(path, init);
      const text = await res.text();
      let data = null;
      if (text) {
        try {
          data = JSON.parse(text);
        } catch (_) {
          data = { error: text };
        }
      }
      if (!res.ok) {
        throw new Error(data?.error || `Request failed (${res.status})`);
      }
      return data;
    }

    async function openDB() {
      try {
        await apiRequest(`${API_BASE}/health`, { cache: 'no-store' });
        dbReady = true;
        invalidateApiStoreCache();
        return true;
      } catch (_) {
        dbReady = false;
        throw new Error('Could not connect to the local server. Start it with: python3 server.py --host 0.0.0.0 --port 8000');
      }
    }

    function openCardBankDB() {
      return Promise.resolve(true);
    }

    function getStoreKeyField(store) {
      return STORE_KEYS[store];
    }

    async function put(store, value) {
      const keyField = getStoreKeyField(store);
      if (!keyField) throw new Error(`Unknown store: ${store}`);
      const key = value?.[keyField];
      if (key === undefined || key === null || key === '') {
        throw new Error(`Missing key "${keyField}" for store "${store}"`);
      }
      await apiRequest(`${API_BASE}/${encodeURIComponent(store)}`, {
        method: 'PUT',
        body: JSON.stringify(value)
      });
      invalidateApiStoreCache();
      return value;
    }

    async function putCardBank(value) {
      if (!dbReady) return Promise.resolve();
      return put('cardbank', value);
    }

    async function del(store, key) {
      const keyField = getStoreKeyField(store);
      if (!keyField) throw new Error(`Unknown store: ${store}`);
      await apiRequest(`${API_BASE}/${encodeURIComponent(store)}/${encodeURIComponent(String(key))}`, {
        method: 'DELETE'
      });
      invalidateApiStoreCache();
    }

    async function getAll(store, options = {}) {
      const opts = options && typeof options === 'object' ? options : {};
      const force = !!opts.force;
      const keyField = getStoreKeyField(store);
      if (!keyField) throw new Error(`Unknown store: ${store}`);
      const ttlMs = Number(API_STORE_CACHE_TTL_BY_STORE[store] ?? API_STORE_CACHE_DEFAULT_TTL_MS);
      const now = Date.now();
      const cached = apiStoreCache.get(store);
      if (!force && cached && now - cached.ts <= ttlMs) {
        return cloneData(cached.data);
      }

      if (!force && apiStoreInFlight.has(store)) {
        return cloneData(await apiStoreInFlight.get(store));
      }

      const requestPromise = (async () => {
        const data = await apiRequest(`${API_BASE}/${encodeURIComponent(store)}`);
        const records = Array.isArray(data) ? data : [];
        apiStoreCache.set(store, { ts: Date.now(), data: records });
        return records;
      })();
      apiStoreInFlight.set(store, requestPromise);
      try {
        return cloneData(await requestPromise);
      } finally {
        apiStoreInFlight.delete(store);
      }
    }

    async function getById(store, key, options = {}) {
      const keyField = getStoreKeyField(store);
      if (!keyField) throw new Error(`Unknown store: ${store}`);
      const safeKey = String(key ?? '').trim();
      if (!safeKey) return null;
      const opts = options && typeof options === 'object' ? options : {};
      const path = `${API_BASE}/${encodeURIComponent(store)}/${encodeURIComponent(safeKey)}`;
      try {
        const data = await getCachedApiQuery(path, opts);
        return (data && typeof data === 'object') ? data : null;
      } catch (err) {
        if (/\(404\)/.test(String(err?.message || ''))) return null;
        throw err;
      }
    }

    function getApiRouteFromPath(path = '') {
      const clean = String(path || '').split('?')[0];
      return clean || '/';
    }

    async function getCachedApiQuery(path, options = {}) {
      const opts = options && typeof options === 'object' ? options : {};
      const force = !!opts.force;
      const cacheKey = String(opts.cacheKey || path);
      const route = getApiRouteFromPath(path);
      const ttlMs = Number(opts.ttlMs ?? API_QUERY_CACHE_TTL_BY_ROUTE[route] ?? API_QUERY_CACHE_DEFAULT_TTL_MS);
      const now = Date.now();
      const cached = apiQueryCache.get(cacheKey);
      if (!force && cached && now - cached.ts <= ttlMs) {
        return cloneData(cached.data);
      }
      if (!force && apiQueryInFlight.has(cacheKey)) {
        return cloneData(await apiQueryInFlight.get(cacheKey));
      }
      const requestPromise = (async () => {
        const data = await apiRequest(path);
        apiQueryCache.set(cacheKey, { ts: Date.now(), data });
        return data;
      })();
      apiQueryInFlight.set(cacheKey, requestPromise);
      try {
        return cloneData(await requestPromise);
      } finally {
        apiQueryInFlight.delete(cacheKey);
      }
    }

    function rebuildTopicDirectory(topics = []) {
      topicDirectory = Array.isArray(topics) ? topics : [];
      const bySubject = new Map();
      const byId = new Map();
      topicDirectory.forEach(topic => {
        const topicId = String(topic?.id || '').trim();
        if (topicId) byId.set(topicId, topic);
        const subjectId = String(topic?.subjectId || '').trim();
        if (!subjectId) return;
        if (!bySubject.has(subjectId)) bySubject.set(subjectId, []);
        bySubject.get(subjectId).push(topic);
      });
      topicDirectoryBySubject = bySubject;
      topicDirectoryById = byId;
      topicDirectoryReady = true;
    }

    async function preloadTopicDirectory(options = {}) {
      const opts = options && typeof options === 'object' ? options : {};
      if (topicDirectoryReady && !opts.force) return cloneData(topicDirectory);
      const data = await getCachedApiQuery(`${API_BASE}/topics?includeCounts=1`, opts);
      const topics = Array.isArray(data) ? data : [];
      rebuildTopicDirectory(topics);
      return cloneData(topicDirectory);
    }

    async function getStats(options = {}) {
      const data = await getCachedApiQuery(`${API_BASE}/stats`, options);
      const src = (data && typeof data === 'object') ? data : {};
      return {
        subjects: Number.isFinite(Number(src.subjects)) ? Number(src.subjects) : 0,
        topics: Number.isFinite(Number(src.topics)) ? Number(src.topics) : 0,
        cards: Number.isFinite(Number(src.cards)) ? Number(src.cards) : 0
      };
    }

    async function getTopicsBySubject(subjectId, options = {}) {
      const id = String(subjectId || '').trim();
      if (!id) return [];
      const opts = options && typeof options === 'object' ? options : {};
      await preloadTopicDirectory({ force: !!opts.force });
      const scoped = topicDirectoryBySubject.get(id) || [];
      return cloneData(scoped);
    }

    async function getCardsByTopicIds(topicIds, options = {}) {
      const ids = Array.isArray(topicIds)
        ? Array.from(new Set(topicIds.map(topicId => String(topicId || '').trim()).filter(Boolean)))
        : [];
      if (!ids.length) return [];
      ids.sort();
      const opts = options && typeof options === 'object' ? options : {};
      const baseParams = new URLSearchParams();
      ids.forEach(topicId => baseParams.append('topicId', topicId));
      const baseQueryPath = `${API_BASE}/cards?${baseParams.toString()}`;
      const requestParams = new URLSearchParams(baseParams.toString());
      let payloadLabel = String(opts.payloadLabel || '').trim();
      if (!payloadLabel && ids.length === 1) {
        const topic = topicDirectoryById.get(ids[0]) || null;
        payloadLabel = topicTraceLabel(topic);
      }
      if (!payloadLabel && ids.length > 1) {
        payloadLabel = `topics-${ids.length}`;
      }
      if (payloadLabel) requestParams.set('payload', payloadLabel);
      const requestPath = `${API_BASE}/cards?${requestParams.toString()}`;
      const data = await getCachedApiQuery(requestPath, { ...opts, cacheKey: baseQueryPath });
      return Array.isArray(data) ? data : [];
    }

    async function getCardsByCardIds(cardIds, options = {}) {
      const ids = Array.isArray(cardIds)
        ? Array.from(new Set(cardIds.map(cardId => String(cardId || '').trim()).filter(Boolean)))
        : [];
      if (!ids.length) return [];
      ids.sort();
      const opts = options && typeof options === 'object' ? options : {};
      const baseParams = new URLSearchParams();
      ids.forEach(cardId => baseParams.append('cardId', cardId));
      const baseQueryPath = `${API_BASE}/cards?${baseParams.toString()}`;
      const requestParams = new URLSearchParams(baseParams.toString());
      const payloadLabel = String(opts.payloadLabel || '').trim();
      if (payloadLabel) requestParams.set('payload', payloadLabel);
      const requestPath = `${API_BASE}/cards?${requestParams.toString()}`;
      const data = await getCachedApiQuery(requestPath, { ...opts, cacheKey: baseQueryPath });
      const rows = Array.isArray(data) ? data : [];
      const wantedIds = new Set(ids);
      return rows.filter(row => wantedIds.has(String(row?.id || '').trim()));
    }

    function buildTopicCardsCacheKey(topicId = '') {
      const id = String(topicId || '').trim();
      if (!id) return '';
      const params = new URLSearchParams();
      params.append('topicId', id);
      return `${API_BASE}/cards?${params.toString()}`;
    }

    function topicTraceLabel(topic = null) {
      const raw = String(topic?.name || 'topic').trim();
      const slug = raw
        .replace(/\s+/g, '-')
        .replace(/[^0-9a-zA-Z\-_.]/g, '')
        .replace(/^-+|-+$/g, '')
        .slice(0, 48);
      return `topic-${slug || 'unknown'}`;
    }

    async function prefetchSubjectTopicCards(topics = [], subjectId = '') {
      const runId = ++topicPrefetchRunId;
      const wantedSubjectId = String(subjectId || '').trim();
      const topicList = Array.isArray(topics) ? topics : [];
      for (const topic of topicList) {
        if (runId !== topicPrefetchRunId) return;
        if (!selectedSubject || String(selectedSubject.id || '') !== wantedSubjectId) return;
        const topicId = String(topic?.id || '').trim();
        if (!topicId) continue;
        const cacheKey = buildTopicCardsCacheKey(topicId);
        if (cacheKey && apiQueryCache.has(cacheKey)) continue;
        try {
          await getCardsByTopicIds([topicId], { payloadLabel: topicTraceLabel(topic) });
        } catch (_) {
          // Keep prefetch best-effort to avoid blocking UI workflows.
        }
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    function triggerHaptic(kind = 'light') {
      const style = kind === 'heavy' ? 'HEAVY' : kind === 'medium' ? 'MEDIUM' : 'LIGHT';

      // Telegram WebApp haptics (if embedded)
      try {
        const tg = window.Telegram?.WebApp?.HapticFeedback;
        if (tg?.impactOccurred) {
          const m = kind === 'heavy' ? 'heavy' : kind === 'medium' ? 'medium' : 'light';
          tg.impactOccurred(m);
          return;
        }
      } catch (_) { }

      // Capacitor haptics (if embedded in native shell)
      try {
        const haptics = window.Capacitor?.Plugins?.Haptics;
        if (haptics?.impact) {
          haptics.impact({ style });
          return;
        }
      } catch (_) { }

      // Cordova TapticEngine (if available)
      try {
        const taptic = window.TapticEngine;
        if (taptic?.impact) {
          const m = kind === 'heavy' ? 'heavy' : kind === 'medium' ? 'medium' : 'light';
          taptic.impact(m);
          return;
        }
      } catch (_) { }

      // Browser vibration fallback (Android browsers)
      try {
        if (!navigator.vibrate) return;
        const duration = kind === 'medium' ? 14 : kind === 'heavy' ? 20 : 8;
        navigator.vibrate(duration);
      } catch (_) { }
    }

    function wireHapticFeedback() {
      const supportsTouch = navigator.maxTouchPoints > 0 || window.matchMedia('(pointer: coarse)').matches;
      if (!supportsTouch) return;

      let lastPulse = 0;
      const pulse = target => {
        if (!target) return;
        if (target.matches(':disabled') || target.getAttribute('aria-disabled') === 'true') return;
        const now = Date.now();
        if (now - lastPulse < 60) return;
        lastPulse = now;
        const kind = target.dataset.grade ? 'medium' : 'light';
        triggerHaptic(kind);
      };

      document.addEventListener('touchstart', e => {
        const target = e.target.closest('button, .btn');
        pulse(target);
      }, { passive: true });

      document.addEventListener('click', e => {
        const target = e.target.closest('button, .btn');
        pulse(target);
      }, true);
    }

    function wireNoZoomGuards() {
      ['gesturestart', 'gesturechange', 'gestureend'].forEach(evt => {
        document.addEventListener(evt, e => e.preventDefault(), { passive: false });
      });

      let lastTouchEnd = 0;
      document.addEventListener('touchend', e => {
        if (e.target.closest('input, textarea, select, [contenteditable=\"true\"]')) return;
        const now = Date.now();
        if (now - lastTouchEnd <= 300) e.preventDefault();
        lastTouchEnd = now;
      }, { passive: false });

      document.addEventListener('wheel', e => {
        if (e.ctrlKey) e.preventDefault();
      }, { passive: false });

      document.addEventListener('keydown', e => {
        const zoomKeys = ['+', '-', '=', '0'];
        if ((e.ctrlKey || e.metaKey) && zoomKeys.includes(e.key)) e.preventDefault();
      });
    }

    const uid = () => {
      if (window.crypto && typeof window.crypto.randomUUID === 'function') {
        return window.crypto.randomUUID();
      }
      if (window.crypto && typeof window.crypto.getRandomValues === 'function') {
        const bytes = new Uint8Array(16);
        window.crypto.getRandomValues(bytes);
        bytes[6] = (bytes[6] & 0x0f) | 0x40;
        bytes[8] = (bytes[8] & 0x3f) | 0x80;
        const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0'));
        return `${hex[0]}${hex[1]}${hex[2]}${hex[3]}-${hex[4]}${hex[5]}-${hex[6]}${hex[7]}-${hex[8]}${hex[9]}-${hex[10]}${hex[11]}${hex[12]}${hex[13]}${hex[14]}${hex[15]}`;
      }
      return `id-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 11)}`;
    };

    function showDialog(dialog) {
      if (!dialog) return;
      if (typeof dialog.showModal === 'function') dialog.showModal();
      else dialog.setAttribute('open', '');
    }

    function closeDialog(dialog) {
      if (!dialog) return;
      if (typeof dialog.close === 'function') dialog.close();
      else dialog.removeAttribute('open');
    }

    let currentView = 0;

    function syncSidebarHiddenState(step = currentView) {
      const studySection = el('studySessionSection');
      const hideForStudy = step === 2 && studySection && !studySection.classList.contains('hidden');
      const hideSidebar = step === 3 || hideForStudy;
      document.body.classList.toggle('sidebar-hidden', hideSidebar);
      if (hideSidebar) document.body.classList.remove('sidebar-open');
    }

    function setView(step = 0) {
      currentView = step;
      el('track').style.transform = `translateX(${-100 * step / 4}%)`;
      if (step !== 3) {
        document.querySelector('#editorPanel .editor-shell')?.classList.remove('sidebar-open');
      }
      syncSidebarHiddenState(step);
    }

    function escapeHTML(str = '') {
      return str.replace(/[&<>"]/g, s => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[s]));
    }

    function isEscaped(str, idx) {
      let count = 0;
      for (let i = idx - 1; i >= 0 && str[i] === '\\'; i--) count++;
      return count % 2 === 1;
    }

    function normalizeTextAlign(value = '') {
      const v = String(value || '').toLowerCase();
      if (v === 'center' || v === 'justify') return v;
      return 'left';
    }

    function hasActiveTextSelection() {
      const selection = window.getSelection ? window.getSelection() : null;
      if (!selection || selection.rangeCount < 1 || selection.isCollapsed) return false;
      return true;
    }

    function tokenizeMathSegments(raw = '') {
      const tokens = [];
      let out = '';
      let i = 0;
      while (i < raw.length) {
        if (raw.startsWith('$$', i) && !isEscaped(raw, i)) {
          let j = i + 2;
          while (j < raw.length) {
            if (raw[j] === '$' && raw[j + 1] === '$' && !isEscaped(raw, j)) break;
            j++;
          }
          if (j < raw.length) {
            const tokenId = tokens.length;
            tokens.push(raw.slice(i, j + 2));
            out += `@@MATH${tokenId}@@`;
            i = j + 2;
            continue;
          }
        }
        if (raw[i] === '$' && !isEscaped(raw, i)) {
          let j = i + 1;
          while (j < raw.length) {
            if (raw[j] === '$' && !isEscaped(raw, j)) break;
            j++;
          }
          if (j < raw.length) {
            const tokenId = tokens.length;
            tokens.push(raw.slice(i, j + 1));
            out += `@@MATH${tokenId}@@`;
            i = j + 1;
            continue;
          }
        }
        if (raw.startsWith('\\[', i)) {
          const j = raw.indexOf('\\]', i + 2);
          if (j !== -1) {
            const tokenId = tokens.length;
            tokens.push(raw.slice(i, j + 2));
            out += `@@MATH${tokenId}@@`;
            i = j + 2;
            continue;
          }
        }
        if (raw.startsWith('\\(', i)) {
          const j = raw.indexOf('\\)', i + 2);
          if (j !== -1) {
            const tokenId = tokens.length;
            tokens.push(raw.slice(i, j + 2));
            out += `@@MATH${tokenId}@@`;
            i = j + 2;
            continue;
          }
        }
        out += raw[i];
        i += 1;
      }
      return { text: out, tokens };
    }

    function applyInlineMarkdown(raw = '') {
      let t = escapeHTML(raw);
      t = t.replace(/\[(.*?)\]\{(#[0-9a-fA-F]{3,8}|[a-zA-Z]+)\}/g, '<span style="color:$2">$1</span>');
      t = t.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
      t = t.replace(/__(.+?)__/g, '<u>$1</u>');
      t = t.replace(/\*(.+?)\*/g, '<em>$1</em>');
      t = t.replace(/--> /g, '&rarr;');
      t = t.replace(/`([^`]+)`/g, '<code>$1</code>');
      return t;
    }

    function restoreMathTokens(html = '', tokens = []) {
      return html.replace(/@@MATH(\d+)@@/g, (_, idx) => {
        const token = tokens[Number(idx)];
        return token ? escapeHTML(token) : `@@MATH${idx}@@`;
      });
    }

    function parseListLineMeta(line = '') {
      const indent = (line.match(/^\s*/) || [''])[0];
      const rest = line.slice(indent.length);

      const orderedMatch = rest.match(/^((?:\d+\.)+)(?:\s+(.*))?$/);
      if (orderedMatch) {
        const sequence = orderedMatch[1]
          .split('.')
          .filter(Boolean)
          .map(num => Number(num))
          .filter(num => Number.isFinite(num) && num >= 0);
        if (sequence.length) {
          return {
            type: 'ol',
            indent,
            text: orderedMatch[2] ?? '',
            sequence
          };
        }
      }

      const unorderedMatch = rest.match(/^([-*‚Ä¢‚ó¶‚ñ™])(?:\s+(.*))?$/);
      if (unorderedMatch) {
        return {
          type: 'ul',
          indent,
          marker: unorderedMatch[1],
          text: unorderedMatch[2] ?? ''
        };
      }
      return null;
    }

    function formatOrderedSequence(sequence = []) {
      const safe = Array.isArray(sequence) ? sequence.filter(n => Number.isFinite(n)) : [];
      if (!safe.length) return '1.';
      return `${safe.join('.')}.`;
    }

    function getNestedBulletMarker(marker = '-') {
      if (marker === '-' || marker === '*') return '‚Ä¢';
      if (marker === '‚Ä¢') return '‚ó¶';
      if (marker === '‚ó¶') return '‚ñ™';
      return '‚ñ™';
    }

    function getOutdentedBulletMarker(marker = '-') {
      if (marker === '‚ñ™') return '‚ó¶';
      if (marker === '‚ó¶') return '‚Ä¢';
      if (marker === '‚Ä¢') return '-';
      if (marker === '*') return '-';
      return '-';
    }

    function getPreviousNonEmptyLineMeta(value = '', currentLineStart = 0) {
      let cursor = currentLineStart - 1;
      while (cursor >= 0) {
        const prevLineStart = value.lastIndexOf('\n', Math.max(0, cursor - 1)) + 1;
        const prevLine = value.slice(prevLineStart, cursor + 1);
        if (prevLine.trim()) return parseListLineMeta(prevLine);
        cursor = prevLineStart - 1;
      }
      return null;
    }

    function getListDepth(meta) {
      if (!meta) return 0;
      const indentDepth = Math.floor(String(meta.indent || '').replace(/\t/g, '  ').length / 2);
      if (meta.type === 'ol') {
        const seqDepth = Math.max(0, (meta.sequence?.length || 1) - 1);
        return Math.max(indentDepth, seqDepth);
      }
      return indentDepth;
    }

    function splitMarkdownTableRow(line = '') {
      const trimmed = String(line || '').trim();
      if (!trimmed || !trimmed.includes('|')) return null;
      let core = trimmed;
      if (core.startsWith('|')) core = core.slice(1);
      if (core.endsWith('|')) core = core.slice(0, -1);
      const cells = [];
      let current = '';
      for (let i = 0; i < core.length; i++) {
        const char = core[i];
        const prev = i > 0 ? core[i - 1] : '';
        if (char === '|' && prev !== '\\') {
          cells.push(current.trim().replace(/\\\|/g, '|'));
          current = '';
          continue;
        }
        current += char;
      }
      cells.push(current.trim().replace(/\\\|/g, '|'));
      if (!cells.length) return null;
      return cells;
    }

    function parseMarkdownTableAlignments(line = '', expectedCols = 0) {
      const cells = splitMarkdownTableRow(line);
      if (!cells || (expectedCols > 0 && cells.length !== expectedCols)) return null;
      const alignments = cells.map(cell => {
        const marker = String(cell || '').replace(/\s+/g, '');
        if (!/^:?-{3,}:?$/.test(marker)) return null;
        if (marker.startsWith(':') && marker.endsWith(':')) return 'center';
        if (marker.endsWith(':')) return 'right';
        return 'left';
      });
      if (alignments.some(align => !align)) return null;
      return alignments;
    }

    function parseTableCellAlignmentToken(cell = '') {
      const raw = String(cell || '');
      const match = raw.match(/^\s*\[\[align:(left|center|right)\]\]\s*/i);
      if (!match) return { align: null, text: raw };
      return {
        align: normalizeTextAlign(match[1]),
        text: raw.slice(match[0].length)
      };
    }

    function renderMarkdownTableHtml(headerCells = [], alignments = [], bodyRows = []) {
      const safeHeader = Array.isArray(headerCells) ? headerCells : [];
      const safeBody = Array.isArray(bodyRows) ? bodyRows : [];
      const cols = safeHeader.length;
      if (!cols) return '';
      const th = safeHeader
        .map((cell, idx) => {
          const parsed = parseTableCellAlignmentToken(cell || '');
          const align = parsed.align || alignments[idx] || 'left';
          return `<th class="md-table-cell md-table-align-${align}">${applyInlineMarkdown(parsed.text || '') || '&nbsp;'}</th>`;
        })
        .join('');
      const rowsHtml = safeBody.map(row => {
        const cells = Array.isArray(row) ? row : [];
        const tds = Array.from({ length: cols }, (_, idx) => {
          const value = cells[idx] ?? '';
          const parsed = parseTableCellAlignmentToken(value);
          const align = parsed.align || alignments[idx] || 'left';
          return `<td class="md-table-cell md-table-align-${align}">${applyInlineMarkdown(parsed.text || '') || '&nbsp;'}</td>`;
        }).join('');
        return `<tr>${tds}</tr>`;
      }).join('');
      return `<div class="md-table-wrap"><div class="md-table-fit"><table class="md-table"><thead><tr>${th}</tr></thead><tbody>${rowsHtml}</tbody></table></div></div>`;
    }

    function markdownToHtml(raw = '') {
      const { text, tokens } = tokenizeMathSegments(raw || '');
      const lines = text.split('\n');
      const out = [];
      const listStack = [];
      const liOpen = [];

      const closeOneLevel = () => {
        const idx = listStack.length - 1;
        if (idx < 0) return;
        if (liOpen[idx]) {
          out.push('</li>');
          liOpen[idx] = false;
        }
        out.push(`</${listStack[idx]}>`);
        listStack.pop();
        liOpen.pop();
      };

      const closeToDepth = (targetDepth = 0) => {
        while (listStack.length > targetDepth) closeOneLevel();
      };

      const openListLevel = (type, start = 1) => {
        if (type === 'ol' && Number.isFinite(start) && start > 1) {
          out.push(`<ol start="${start}">`);
        } else {
          out.push(`<${type}>`);
        }
        listStack.push(type);
        liOpen.push(false);
      };

      const ensureDepth = (depth, meta) => {
        while (listStack.length < depth + 1) {
          const parentIdx = listStack.length - 1;
          if (parentIdx >= 0 && !liOpen[parentIdx]) {
            out.push('<li>');
            liOpen[parentIdx] = true;
          }
          const levelIndex = listStack.length;
          const start = meta.type === 'ol' ? Number(meta.sequence?.[levelIndex] || 1) : 1;
          openListLevel(meta.type, start);
        }
      };

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const headerCells = splitMarkdownTableRow(line);
        const alignments = headerCells && i + 1 < lines.length
          ? parseMarkdownTableAlignments(lines[i + 1], headerCells.length)
          : null;
        if (headerCells && alignments) {
          closeToDepth(0);
          const bodyRows = [];
          let j = i + 2;
          while (j < lines.length) {
            const rowCells = splitMarkdownTableRow(lines[j]);
            if (!rowCells || rowCells.length !== headerCells.length) break;
            bodyRows.push(rowCells);
            j += 1;
          }
          out.push(renderMarkdownTableHtml(headerCells, alignments, bodyRows));
          i = j - 1;
          continue;
        }

        const meta = parseListLineMeta(line);
        if (meta) {
          const depth = getListDepth(meta);
          closeToDepth(depth + 1);
          ensureDepth(depth, meta);

          if (listStack[depth] !== meta.type) {
            if (liOpen[depth]) {
              out.push('</li>');
              liOpen[depth] = false;
            }
            out.push(`</${listStack[depth]}>`);
            listStack.pop();
            liOpen.pop();
            const start = meta.type === 'ol' ? Number(meta.sequence?.[depth] || 1) : 1;
            openListLevel(meta.type, start);
          }

          if (liOpen[depth]) {
            out.push('</li>');
            liOpen[depth] = false;
          }

          const item = meta.text ? applyInlineMarkdown(meta.text) : '<br>';
          out.push(`<li>${item}`);
          liOpen[depth] = true;
          continue;
        }

        closeToDepth(0);
        if (!line.trim()) {
          out.push('<div class="md-line"><br></div>');
        } else {
          out.push(`<div class="md-line">${applyInlineMarkdown(line)}</div>`);
        }
      }
      closeToDepth(0);
      return restoreMathTokens(out.join(''), tokens);
    }

    function hasPotentialMathContent(text = '') {
      return /(\$\$?[^$]|\\\(|\\\[)/.test(String(text || ''));
    }

    function forceMathMlOnly(container) {
      if (!container) return;
      container.querySelectorAll('.katex').forEach(node => {
        node.querySelectorAll('.katex-html').forEach(htmlNode => htmlNode.remove());
        const mathmlNode = node.querySelector('.katex-mathml');
        if (mathmlNode) mathmlNode.classList.add('katex-mathml-only');
      });
    }

    function renderKatexInContainer(container) {
      if (!container) return false;
      if (!hasPotentialMathContent(container.textContent || '')) {
        container.dataset.mathPending = '0';
        return true;
      }
      if (!window.renderMathInElement) {
        container.dataset.mathPending = '1';
        return false;
      }
      try {
        window.renderMathInElement(container, KATEX_RENDER_OPTIONS);
        forceMathMlOnly(container);
        container.dataset.mathPending = '0';
        return true;
      } catch (err) {
        container.dataset.mathPending = '1';
        return false;
      }
    }

    let overviewTableFitScheduled = false;
    function fitOverviewTables() {
      const wraps = document.querySelectorAll(
        '.card-tile .rich-content .md-table-wrap, .topic-search-result .rich-content .md-table-wrap'
      );
      wraps.forEach(wrap => {
        const fit = wrap.querySelector('.md-table-fit');
        const table = wrap.querySelector('.md-table');
        if (!fit || !table) return;

        // Reset previous scaling before taking fresh measurements.
        wrap.classList.remove('md-table-wrap-fitted');
        wrap.style.height = '';
        fit.style.width = '';
        fit.style.transform = '';

        const availableWidth = wrap.clientWidth;
        const naturalWidth = table.scrollWidth;
        if (!availableWidth || !naturalWidth) return;
        if (naturalWidth <= availableWidth + 1) return;

        const scale = availableWidth / naturalWidth;
        fit.style.width = `${naturalWidth}px`;
        fit.style.transform = `scale(${scale})`;
        wrap.style.height = `${Math.ceil(table.scrollHeight * scale)}px`;
        wrap.classList.add('md-table-wrap-fitted');
      });
    }

    function scheduleOverviewTableFit() {
      if (overviewTableFitScheduled) return;
      overviewTableFitScheduled = true;
      requestAnimationFrame(() => {
        overviewTableFitScheduled = false;
        fitOverviewTables();
      });
    }

    function rerenderAllRichMath() {
      document.querySelectorAll('.rich-content').forEach(node => renderKatexInContainer(node));
      scheduleOverviewTableFit();
    }

    function renderRich(container, content, options = {}) {
      if (!container) return;
      const textAlign = normalizeTextAlign(options.textAlign);
      container.classList.add('rich-content');
      container.classList.remove('rich-align-left', 'rich-align-center', 'rich-align-justify');
      container.classList.add(`rich-align-${textAlign}`);
      container.innerHTML = markdownToHtml(content || '');
      scheduleOverviewTableFit();
      if (renderKatexInContainer(container)) return;
      ensureKatexLoaded().then(loaded => {
        if (!loaded) return;
        rerenderAllRichMath();
      });
    }

    function isInMathMode(text, pos) {
      let count = 0;
      for (let i = 0; i < pos; i++) {
        if (text[i] === '$' && text[i - 1] !== '\\') count++;
      }
      return count % 2 === 1;
    }

    function attachAutoClose(elm) {
      if (!elm) return;
      const pairs = { '(': ')', '[': ']', '{': '}', '$': '$' };
      elm.addEventListener('keydown', e => {
        if (!pairs[e.key]) return;
        const start = elm.selectionStart;
        const end = elm.selectionEnd;
        const text = elm.value;
        if (!isInMathMode(text, start)) return;
        e.preventDefault();
        const open = e.key;
        const close = pairs[e.key];
        const before = text.slice(0, start);
        const after = text.slice(end);
        elm.value = `${before}${open}${close}${after}`;
        const cursor = start + 1;
        elm.setSelectionRange(cursor, cursor);
      });
    }

    function fileToDataUrl(file) {
      return new Promise(res => {
        const fr = new FileReader();
        fr.onload = () => res(fr.result);
        fr.readAsDataURL(file);
      });
    }

    function normalizeImageList(rawImages, fallbackImage = '') {
      const images = [];
      const seen = new Set();
      const push = value => {
        const src = typeof value === 'string' ? value.trim() : '';
        if (!src || seen.has(src)) return;
        seen.add(src);
        images.push(src);
      };
      if (Array.isArray(rawImages)) rawImages.forEach(push);
      else if (rawImages && typeof rawImages === 'object' && typeof rawImages.length === 'number') {
        Array.from(rawImages).forEach(push);
      } else {
        push(rawImages);
      }
      if (!images.length) push(fallbackImage);
      return images;
    }

    function getCardImageList(card, side = 'Q') {
      const key = String(side || 'Q').toUpperCase() === 'A' ? 'A' : 'Q';
      const listKey = key === 'Q' ? 'imagesQ' : 'imagesA';
      const fallback = key === 'Q'
        ? card?.imageDataQ || card?.imageData || ''
        : card?.imageDataA || '';
      return normalizeImageList(card?.[listKey], fallback);
    }

    function getFieldImageList(field, legacyKey = '') {
      if (!field) return [];
      let parsed = [];
      const raw = String(field.dataset.images || '').trim();
      if (raw) {
        try {
          const payload = JSON.parse(raw);
          parsed = normalizeImageList(payload);
        } catch (err) {
          parsed = normalizeImageList(raw);
        }
      }
      return normalizeImageList(parsed, field.dataset[legacyKey] || '');
    }

    function setFieldImageList(field, images, legacyKey = '') {
      if (!field) return [];
      const normalized = normalizeImageList(images);
      if (normalized.length) field.dataset.images = JSON.stringify(normalized);
      else delete field.dataset.images;
      if (legacyKey) field.dataset[legacyKey] = normalized[0] || '';
      return normalized;
    }

    function setImagePreview(previewEl, dataUrls, onRemoveAt) {
      if (!previewEl) return;
      const images = normalizeImageList(dataUrls);
      if (!images.length) {
        previewEl.classList.remove('has-image', 'single-image', 'multi-image');
        previewEl.innerHTML = `
          <div class="image-preview-empty-state" aria-hidden="true">
            <img class="image-preview-drop-icon" src="icons/drop_image.png" alt="" style="width: 48px; height: 48px;"/>
          </div>
        `;
        return;
      }
      previewEl.classList.add('has-image');
      previewEl.classList.toggle('single-image', images.length === 1);
      previewEl.classList.toggle('multi-image', images.length > 1);
      previewEl.innerHTML = '';

      const createImageWrap = (src, idx, variant = 'single') => {
        const wrap = document.createElement('div');
        wrap.className = `image-preview-wrap image-preview-wrap-${variant}`;
        const img = document.createElement('img');
        img.src = src;
        img.alt = `preview ${idx + 1}`;
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'image-remove-btn';
        btn.setAttribute('aria-label', `Remove image ${idx + 1}`);
        btn.innerHTML = '<img src="icons/trash.svg" alt="" aria-hidden="true">';
        btn.onclick = e => {
          e.stopPropagation();
          if (typeof onRemoveAt === 'function') onRemoveAt(idx);
        };
        wrap.append(img, btn);
        return wrap;
      };

      const createDropTile = (variant = 'single') => {
        const tile = document.createElement('div');
        tile.className = `image-preview-drop-tile image-preview-drop-tile-${variant}`;
        tile.innerHTML = '<img class="image-preview-drop-icon" src="icons/drop_image.png" alt="" aria-hidden="true">';
        tile.setAttribute('title', 'Drop more images');
        return tile;
      };

      if (images.length === 1) {
        const row = document.createElement('div');
        row.className = 'image-preview-single-layout';
        row.appendChild(createImageWrap(images[0], 0, 'single'));
        row.appendChild(createDropTile('single'));
        previewEl.appendChild(row);
        return;
      }

      const row = document.createElement('div');
      row.className = 'image-preview-multi-layout';
      const stack = document.createElement('div');
      stack.className = 'image-preview-stack';
      images.forEach((src, idx) => {
        const wrap = createImageWrap(src, idx, 'stack');
        const offsetX = Math.min(10 * idx, 36);
        const rotation = idx === 0 ? -10 : idx === 1 ? 0 : Math.min(10 + (idx - 2) * 2, 16);
        wrap.style.setProperty('--stack-left', `${offsetX}px`);
        wrap.style.setProperty('--stack-rotation', `${rotation}deg`);
        wrap.style.setProperty('--stack-z', String(idx + 1));
        stack.appendChild(wrap);
      });
      row.appendChild(stack);
      row.appendChild(createDropTile('multi'));
      previewEl.appendChild(row);
    }

    function syncFieldImagePreview(field, previewEl, legacyKey = '', onChange = null) {
      if (!field || !previewEl) return;
      const images = getFieldImageList(field, legacyKey);
      setImagePreview(previewEl, images, removeIdx => {
        const current = getFieldImageList(field, legacyKey);
        const next = current.filter((_, idx) => idx !== removeIdx);
        setFieldImageList(field, next, legacyKey);
        syncFieldImagePreview(field, previewEl, legacyKey, onChange);
        if (typeof onChange === 'function') onChange(next);
      });
    }

    function appendImagesToField(field, previewEl, newImages, legacyKey = '', onChange = null) {
      if (!field || !previewEl) return;
      const current = getFieldImageList(field, legacyKey);
      const next = normalizeImageList([...current, ...normalizeImageList(newImages)]);
      setFieldImageList(field, next, legacyKey);
      syncFieldImagePreview(field, previewEl, legacyKey, onChange);
      if (typeof onChange === 'function') onChange(next);
    }

    function replaceFieldImages(field, previewEl, images, legacyKey = '', onChange = null) {
      if (!field || !previewEl) return;
      const next = setFieldImageList(field, images, legacyKey);
      syncFieldImagePreview(field, previewEl, legacyKey, onChange);
      if (typeof onChange === 'function') onChange(next);
    }

    function attachImageDrop(target, onImages) {
      if (!target) return;
      const prevent = e => { e.preventDefault(); e.stopPropagation(); };
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
        target.addEventListener(evt, prevent);
      });
      target.addEventListener('drop', async e => {
        const files = Array.from(e.dataTransfer?.files || [])
          .filter(file => file && String(file.type || '').startsWith('image/'));
        if (!files.length) return;
        const dataUrls = normalizeImageList(await Promise.all(files.map(fileToDataUrl)));
        if (!dataUrls.length) return;
        if (typeof onImages === 'function') onImages(dataUrls);
      });
    }

    function attachImagePicker(target, onImages) {
      if (!target) return;
      if (target.dataset.imagePickerBound === '1') return;
      target.dataset.imagePickerBound = '1';

      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'image/*';
      fileInput.multiple = true;
      fileInput.tabIndex = -1;
      fileInput.setAttribute('aria-hidden', 'true');
      fileInput.style.display = 'none';
      document.body.appendChild(fileInput);

      fileInput.addEventListener('change', async () => {
        const files = Array.from(fileInput.files || [])
          .filter(file => file && String(file.type || '').startsWith('image/'));
        fileInput.value = '';
        if (!files.length) return;
        const dataUrls = normalizeImageList(await Promise.all(files.map(fileToDataUrl)));
        if (!dataUrls.length) return;
        if (typeof onImages === 'function') onImages(dataUrls);
      });

      target.addEventListener('click', e => {
        const clickTarget = e.target;
        if (!(clickTarget instanceof Element)) return;
        if (clickTarget.closest('.image-remove-btn')) return;

        const isDropTileClick = !!clickTarget.closest('.image-preview-drop-tile');
        const isEmptyStateClick = !!clickTarget.closest('.image-preview-empty-state');
        const isDropIconClick = clickTarget.classList.contains('image-preview-drop-icon');
        const isEmptyContainerClick = clickTarget === target && !target.classList.contains('has-image');
        if (!isDropTileClick && !isEmptyStateClick && !isDropIconClick && !isEmptyContainerClick) return;

        fileInput.click();
      });
    }

    function appendCardImages(container, images = [], className = 'card-thumb', altPrefix = 'Card image') {
      if (!container) return;
      const normalized = normalizeImageList(images);
      normalized.forEach((src, idx) => {
        const thumb = document.createElement('img');
        thumb.src = src;
        thumb.className = className;
        thumb.alt = `${altPrefix} ${idx + 1}`;
        container.appendChild(thumb);
      });
    }

    function appendSessionImages(container, images = [], altPrefix = 'Card image') {
      if (!container) return;
      const normalized = normalizeImageList(images);
      normalized.forEach((src, idx) => {
        const img = buildSessionCardImage(src, `${altPrefix} ${idx + 1}`);
        container.appendChild(img);
      });
    }

    function getCardImagePayload(imagesQ, imagesA) {
      const q = normalizeImageList(imagesQ);
      const a = normalizeImageList(imagesA);
      return {
        imagesQ: q,
        imagesA: a,
        imageDataQ: q[0] || '',
        imageDataA: a[0] || ''
      };
    }

    function applySubjectTheme(accent) {
      const normHex = normalizeHexColor(accent || '#2dd4bf');
      const rgba = a => hexToRgba(normHex, a);
      document.documentElement.style.setProperty('--accent', normHex);
      document.documentElement.style.setProperty('--accent-glow', rgba(0.35));
      document.documentElement.style.setProperty('--accent-ring', rgba(0.9));
      document.documentElement.style.setProperty('--accent-glow-strong', rgba(0.6));
      document.documentElement.style.setProperty('--accent-glow-soft', rgba(0.35));
      document.documentElement.style.setProperty('--panel-accent', rgba(0.12));
      document.documentElement.style.setProperty('--tile-accent-bg', rgba(0.18));
      document.documentElement.style.setProperty('--face-accent', rgba(0.14));
    }

    function normalizeHexColor(accent = '#2dd4bf') {
      const hex = String(accent || '#2dd4bf').replace('#', '');
      const norm = hex.length === 3
        ? hex.split('').map(c => c + c).join('')
        : hex.padEnd(6, '0').slice(0, 6);
      return `#${norm}`;
    }

    function hexToRgba(accent = '#2dd4bf', alpha = 1) {
      const safeHex = normalizeHexColor(accent).slice(1);
      const r = parseInt(safeHex.slice(0, 2), 16);
      const g = parseInt(safeHex.slice(2, 4), 16);
      const b = parseInt(safeHex.slice(4, 6), 16);
      const a = Math.max(0, Math.min(1, Number(alpha)));
      return `rgba(${r}, ${g}, ${b}, ${a})`;
    }

    function getSubjectLastEditedAt(subject) {
      const raw = subject?.meta?.updatedAt
        ?? subject?.updatedAt
        ?? subject?.meta?.createdAt
        ?? subject?.createdAt
        ?? 0;
      if (!raw) return 0;
      if (typeof raw === 'number') return raw;
      const parsed = Date.parse(raw);
      return Number.isNaN(parsed) ? 0 : parsed;
    }

    function sortSubjectsByLastEdited(subjects = []) {
      return [...subjects].sort((a, b) => {
        const tsDiff = getSubjectLastEditedAt(b) - getSubjectLastEditedAt(a);
        if (tsDiff !== 0) return tsDiff;
        return String(a?.name || '').localeCompare(String(b?.name || ''));
      });
    }

    function buildSubjectRecord(subject = {}, overrides = {}, nowIso = new Date().toISOString()) {
      const createdAt = subject?.meta?.createdAt || subject?.createdAt || nowIso;
      const updatedAt = overrides.updatedAt || nowIso;
      return {
        ...subject,
        ...overrides,
        createdAt,
        updatedAt,
        meta: {
          ...(subject.meta || {}),
          createdAt,
          updatedAt
        }
      };
    }

    async function touchSubject(subjectId, whenIso = new Date().toISOString()) {
      if (!subjectId) return;
      const subject = (await getAll('subjects')).find(s => s.id === subjectId);
      if (!subject) return;
      const updatedSubject = buildSubjectRecord(subject, {}, whenIso);
      await put('subjects', updatedSubject);
      if (selectedSubject?.id === subjectId) {
        selectedSubject = { ...selectedSubject, ...updatedSubject };
      }
    }

    async function touchSubjectByTopicId(topicId, whenIso = new Date().toISOString()) {
      if (!topicId) return;
      const topic = await getById('topics', topicId);
      if (!topic?.subjectId) return;
      await touchSubject(topic.subjectId, whenIso);
    }

    async function refreshSidebar() {
      const subjects = sortSubjectsByLastEdited(await getAll('subjects'));
      const list = el('subjectList');
      list.innerHTML = '';
      subjects.forEach(s => {
        const chip = document.createElement('div');
        chip.className = 'tile subject-tile';
        const accent = normalizeHexColor(s.accent || '#2dd4bf');
        chip.style.setProperty('--tile-accent', accent);
        chip.style.setProperty('--subject-accent', accent);
        chip.style.setProperty('--subject-accent-bg', hexToRgba(accent, 0.18));
        chip.style.setProperty('--subject-accent-glow', hexToRgba(accent, 0.34));
        chip.innerHTML = `
          <div class="tile-row">
            <div style="display:flex;align-items:center;gap:10px;">
              <div>${escapeHTML(s.name)}</div>
            </div>
            <div class="tile-menu">
              <button class="btn tile-menu-btn" type="button">‚ãØ</button>
            </div>
          </div>
        `;
        chip.onclick = () => {
          selectedSubject = s;
          selectedTopic = null;
          setTopicSelectionMode(false);
          applySubjectTheme(s.accent || '#2dd4bf');
          loadTopics();
          setView(1);
          document.body.classList.remove('sidebar-open');
        };
        const menuBtn = chip.querySelector('.tile-menu-btn');
        if (menuBtn) {
          menuBtn.onclick = e => {
            e.stopPropagation();
            editingSubjectId = s.id;
            el('editSubjectName').value = s.name;
            el('editSubjectColor').value = s.accent || '#2dd4bf';
            el('subjectEditDialog').showModal();
          };
        }
        list.appendChild(chip);
      });
      const stats = await getStats();
      const summarySubjectsEl = el('summarySubjects');
      const summaryTopicsEl = el('summaryTopics');
      const summaryCardsEl = el('summaryCards');
      if (summarySubjectsEl) summarySubjectsEl.textContent = `${subjects.length} Subjects`;
      if (summaryTopicsEl) summaryTopicsEl.textContent = `${stats.topics} Topics`;
      if (summaryCardsEl) summaryCardsEl.textContent = `${stats.cards} Cards`;
      applySubjectTheme(selectedSubject?.accent || '#2dd4bf');
      loadHomeTopics();
    }

    async function loadHomeTopics() {
      const wrap = el('homeTopics');
      if (!wrap) return;
      if (!selectedSubject) {
        wrap.innerHTML = '<div class="tiny">Select a subject from the sidebar to drill down.</div>';
        return;
      }
      const topics = await getTopicsBySubject(selectedSubject.id);
      if (!topics.length) {
        wrap.innerHTML = '<div class="tiny">No topics yet.</div>';
        return;
      }
      wrap.innerHTML = '';
      topics.forEach(t => {
        const tile = document.createElement('div');
        tile.className = 'tile topic-tile';
        tile.textContent = t.name;
        tile.onclick = () => {
          selectedTopic = t;
          session.active = false;
          el('cardsOverviewSection').classList.remove('hidden');
          el('studySessionSection')?.classList.add('hidden');
          renderSessionPills();
          loadDeck();
          setView(2);
        };
        wrap.appendChild(tile);
      });
    }

    function renderSessionSizeCounter() {
      const valueEl = el('sessionSizeValue');
      if (!valueEl) return;
      const current = availableSessionCards > 0 ? sessionSize : 0;
      valueEl.textContent = `${current} / ${availableSessionCards}`;
    }

    function openStudyImageLightbox(src) {
      const lightbox = el('sessionImageLightbox');
      const lightboxImg = el('sessionImageLightboxImg');
      if (!lightbox || !lightboxImg || !src) return;
      lightboxImg.src = src;
      lightbox.classList.remove('hidden');
      document.body.classList.add('session-image-open');
    }

    function closeStudyImageLightbox() {
      const lightbox = el('sessionImageLightbox');
      const lightboxImg = el('sessionImageLightboxImg');
      if (!lightbox || !lightboxImg) return;
      lightbox.classList.add('hidden');
      lightboxImg.src = '';
      document.body.classList.remove('session-image-open');
    }

    function buildSessionCardImage(src, alt = 'Flashcard image') {
      const img = document.createElement('img');
      img.src = src;
      img.alt = alt;
      img.className = 'session-card-image';
      img.addEventListener('click', e => {
        e.stopPropagation();
        openStudyImageLightbox(src);
      });
      return img;
    }

    async function refreshTopicSessionMeta(topicsForSubject = null) {
      if (!selectedSubject) {
        availableSessionCards = 0;
        sessionSize = 0;
        renderSessionSizeCounter();
        renderSessionFilterSummary();
        return;
      }

      const topics = topicsForSubject || (await getTopicsBySubject(selectedSubject.id));
      const selectedTopics = topics.filter(t => selectedTopicIds.has(t.id));
      const selectedTopicLabel = el('selectedTopicsSummary');
      if (selectedTopicLabel) {
        selectedTopicLabel.innerHTML = '';
        if (!selectedTopics.length) {
          selectedTopicLabel.classList.add('is-empty');
          selectedTopicLabel.textContent = 'Choose at least one topic below.';
        } else {
          selectedTopicLabel.classList.remove('is-empty');
          selectedTopics.forEach(topic => {
            const pill = document.createElement('span');
            pill.className = 'study-topic-pill';
            const name = String(topic?.name || '').trim() || 'Untitled topic';
            pill.textContent = name;
            pill.setAttribute('title', name);
            selectedTopicLabel.appendChild(pill);
          });
        }
      }

      const selectedIds = selectedTopics.map(t => t.id);
      const cards = await getEligibleSessionCardsByTopicIds(selectedIds, sessionFilterState);
      availableSessionCards = cards.length;
      if (availableSessionCards <= 0) sessionSize = 0;
      else if (sessionSize <= 0) sessionSize = Math.min(15, availableSessionCards);
      else sessionSize = Math.min(sessionSize, availableSessionCards);
      renderSessionSizeCounter();
      renderSessionFilterSummary();

      const startBtn = el('startSessionBtn');
      if (startBtn) startBtn.disabled = !selectedTopics.length || availableSessionCards <= 0;
    }

    function openCreateCardEditor() {
      if (!selectedTopic) {
        alert('Pick a topic first.');
        return;
      }
      setDeckSelectionMode(false);
      el('editorTitle').textContent = `Create Flashcards ‚Ä¢ ${selectedTopic.name}`;
      el('cardPrompt').value = '';
      el('cardAnswer').value = '';
      replaceFieldImages(el('cardPrompt'), el('questionImagePreview'), [], 'imageDataQ', updateCreateValidation);
      replaceFieldImages(el('cardAnswer'), el('answerImagePreview'), [], 'imageDataA', updateCreateValidation);
      const primaryToggle = el('primaryAnswerToggle');
      if (primaryToggle) primaryToggle.checked = true;
      el('mcqOptions').innerHTML = '';
      setMcqModeState(false, false);
      applyCreateQuestionTextAlign('center');
      applyCreateAnswerTextAlign('center');
      applyCreateOptionsTextAlign('left');
      createTouched = false;
      updateCreateValidation();
      setPreview('questionPreview', '', createQuestionTextAlign);
      setPreview('answerPreview', '', createAnswerTextAlign);
      loadEditorCards();
      setView(3);
    }

    async function loadTopics() {
      if (!selectedSubject) return;
      topicPrefetchRunId += 1;
      el('topicTitle').textContent = selectedSubject.name;
      applySubjectTheme(selectedSubject.accent || '#2dd4bf');
      const topics = await getTopicsBySubject(selectedSubject.id, { includeCounts: true });
      const topicListTitle = el('topicListTitle');
      if (topicListTitle) topicListTitle.textContent = topics.length === 1 ? 'Topic' : 'Topics';
      const validTopicIds = new Set(topics.map(t => t.id));
      const previousSelection = selectedTopicIds;
      selectedTopicIds = new Set(
        [...previousSelection].filter(topicId => validTopicIds.has(topicId))
      );
      const previousTopicSelection = topicSelectedIds;
      topicSelectedIds = new Set(
        [...previousTopicSelection].filter(topicId => validTopicIds.has(topicId))
      );
      if (!topics.length) setTopicSelectionMode(false);
      const list = el('topicList');
      list.innerHTML = '';
      topics.forEach(t => {
        const cardCount = Number.isFinite(Number(t?.cardCount)) ? Number(t.cardCount) : 0;
        const cardCountLabel = `${cardCount} ${cardCount === 1 ? 'card' : 'cards'}`;
        const row = document.createElement('div');
        row.className = 'tile topic-tile';
        if (topicSelectionMode) {
          row.classList.add('selection-mode');
          row.innerHTML = `
            <div class="tile-check">
              <div class="topic-tile-main">
                <div class="topic-tile-name">${escapeHTML(t.name)}</div>
                <div class="tiny topic-card-count">${cardCountLabel}</div>
              </div>
            </div>
          `;
          const selectWrap = document.createElement('label');
          selectWrap.className = 'card-select-control';
          selectWrap.innerHTML = `<input type="checkbox" aria-label="Select topic" />`;
          const checkbox = selectWrap.querySelector('input');
          checkbox.checked = topicSelectedIds.has(t.id);
          row.classList.toggle('selected-for-bulk', checkbox.checked);
          checkbox.addEventListener('click', e => e.stopPropagation());
          checkbox.addEventListener('change', () => {
            toggleTopicSelection(t.id, checkbox.checked);
            row.classList.toggle('selected-for-bulk', checkbox.checked);
          });
          row.addEventListener('click', e => {
            if (e.target.closest('.card-select-control')) return;
            const nextChecked = !checkbox.checked;
            checkbox.checked = nextChecked;
            toggleTopicSelection(t.id, nextChecked);
            row.classList.toggle('selected-for-bulk', nextChecked);
          });
          row.appendChild(selectWrap);
        } else {
          row.innerHTML = `
            <div class="tile-check">
              <div class="topic-tile-main">
                <div class="topic-tile-name">${escapeHTML(t.name)}</div>
                <div class="tiny topic-card-count">${cardCountLabel}</div>
              </div>
              <input type="checkbox" data-topic-id="${t.id}" />
            </div>
          `;
          const checkbox = row.querySelector('input[type="checkbox"]');
          checkbox.checked = selectedTopicIds.has(t.id);
          row.classList.toggle('selected', selectedTopicIds.has(t.id));
          row.onclick = () => {
            selectedTopic = t;
            session.active = false;
            el('cardsOverviewSection')?.classList.remove('hidden');
            el('studySessionSection')?.classList.add('hidden');
            renderSessionPills();
            if (cardCount <= 0) {
              openCreateCardEditor();
              return;
            }
            loadDeck();
            setView(2);
          };
          checkbox.addEventListener('click', async e => {
            e.stopPropagation();
            if (checkbox.checked) selectedTopicIds.add(t.id);
            else selectedTopicIds.delete(t.id);
            row.classList.toggle('selected', checkbox.checked);
            await refreshTopicSessionMeta(topics);
          });
        }
        list.appendChild(row);
      });
      if (!topics.length) list.innerHTML = '<div class="tiny">No topics yet.</div>';
      updateTopicSelectionUi();
      await refreshTopicSessionMeta(topics);
      if (topics.length) {
        void prefetchSubjectTopicCards(topics, selectedSubject.id);
      }
    }

    function syncPrimaryMcqUi(edit = false) {
      const field = el(edit ? 'editPrimaryAnswerRow' : 'primaryAnswerRow');
      const badge = el(edit ? 'editPrimaryAnswerBadge' : 'primaryAnswerBadge');
      const toggle = el(edit ? 'editPrimaryAnswerToggle' : 'primaryAnswerToggle');
      if (!field || !badge || !toggle) return;
      const isCorrect = !!toggle.checked;
      field.classList.toggle('correct', isCorrect);
      field.classList.toggle('wrong', !isCorrect);
      badge.className = `mcq-badge ${isCorrect ? 'correct' : 'wrong'}`;
      badge.textContent = isCorrect ? 'Correct Answer ‚úì' : 'Wrong Answer ‚úï';
    }

    function setMcqModeState(edit = false, enabled = false) {
      const field = el(edit ? 'editPrimaryAnswerRow' : 'primaryAnswerRow');
      const header = el(edit ? 'editPrimaryAnswerHeader' : 'primaryAnswerHeader');
      const toggle = el(edit ? 'editPrimaryAnswerToggle' : 'primaryAnswerToggle');
      const optionsEl = el(edit ? 'editMcqOptions' : 'mcqOptions');
      const optionsToolbar = el(edit ? 'editOptionsToolbar' : 'createOptionsToolbar');
      const answerInput = el(edit ? 'editCardAnswer' : 'cardAnswer');
      if (!field || !header || !toggle || !optionsEl) return;
      if (edit) editMcqMode = enabled;
      else mcqMode = enabled;
      optionsEl.classList.toggle('hidden', !enabled);
      if (optionsToolbar) optionsToolbar.classList.toggle('hidden', !enabled);
      header.classList.toggle('hidden', !enabled);
      field.classList.toggle('mcq-primary', enabled);
      field.classList.toggle('mcq-row', enabled);
      if (answerInput instanceof HTMLTextAreaElement) {
        answerInput.wrap = enabled ? 'off' : 'soft';
      }
      if (!enabled) {
        field.classList.remove('correct', 'wrong');
        return;
      }
      toggle.onchange = () => syncPrimaryMcqUi(edit);
      syncPrimaryMcqUi(edit);
      if (answerInput instanceof HTMLTextAreaElement) {
        enforcePrimaryMcqAnswerSingleLine(answerInput);
      }
      if (!edit) updateCreateValidation();
    }

    function isPrimaryMcqAnswerSingleLineMode(textarea) {
      if (!(textarea instanceof HTMLTextAreaElement)) return false;
      if (textarea.id === 'cardAnswer') return !!el('primaryAnswerRow')?.classList.contains('mcq-primary');
      if (textarea.id === 'editCardAnswer') return !!el('editPrimaryAnswerRow')?.classList.contains('mcq-primary');
      return false;
    }

    function enforcePrimaryMcqAnswerSingleLine(textarea) {
      if (!(textarea instanceof HTMLTextAreaElement)) return;
      if (!isPrimaryMcqAnswerSingleLineMode(textarea)) return;
      const value = String(textarea.value || '');
      const normalized = value.replace(/\r\n?/g, '\n').replace(/\n+/g, ' ');
      if (normalized === value) return;
      const pos = textarea.selectionStart ?? normalized.length;
      const nextPos = Math.max(0, Math.min(normalized.length, pos));
      textarea.value = normalized;
      textarea.setSelectionRange(nextPos, nextPos);
      if (textarea.id === 'cardAnswer') updateCreateValidation();
    }

    function handlePrimaryMcqAnswerKeydown(e) {
      const textarea = e.target;
      if (!(textarea instanceof HTMLTextAreaElement)) return;
      if (!isPrimaryMcqAnswerSingleLineMode(textarea)) return;
      if (e.key === 'Enter') {
        e.preventDefault();
      }
    }

    function getAdditionalMcqRowCount(edit = false) {
      const optionsEl = el(edit ? 'editMcqOptions' : 'mcqOptions');
      if (!optionsEl) return 0;
      return optionsEl.querySelectorAll('.mcq-row[data-primary="false"]').length;
    }

    function syncMcqPrimaryAnswerMode(edit = false) {
      const hasAdditionalRows = getAdditionalMcqRowCount(edit) > 0;
      setMcqModeState(edit, hasAdditionalRows);
      if (!edit) updateCreateValidation();
    }

    let createTouched = false;
    function updateCreateValidation(showErrors = false) {
      const question = el('cardPrompt');
      const answer = el('cardAnswer');
      const hasQuestionImage = getFieldImageList(question, 'imageDataQ').length > 0;
      const hasAnswerImage = getFieldImageList(answer, 'imageDataA').length > 0;
      const qValid = question.value.trim().length > 0 || hasQuestionImage;
      const aValid = mcqMode
        ? getCreateOptionCount() > 0
        : answer.value.trim().length > 0 || hasAnswerImage;
      const isValid = qValid && aValid;

      const addBtn = el('addCardBtn');
      if (addBtn) addBtn.disabled = !isValid;

      const shouldShow = showErrors || createTouched;
      question.classList.toggle('field-invalid', shouldShow && !qValid);
      answer.classList.toggle('field-invalid', shouldShow && !aValid);
      el('questionError').classList.toggle('hidden', !(shouldShow && !qValid));
      el('answerError').classList.toggle('hidden', !(shouldShow && !aValid));
      return isValid;
    }

    function debounce(fn, wait = 300) {
      let t = null;
      return (...args) => {
        if (t) clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    function setPreview(previewId, value, textAlign = 'left') {
      const preview = el(previewId);
      if (!preview) return;
      const align = normalizeTextAlign(textAlign);
      preview.classList.add('rich-content');
      preview.classList.remove('rich-align-left', 'rich-align-center', 'rich-align-justify');
      preview.classList.add(`rich-align-${align}`);
      if (!value || !value.trim()) {
        preview.innerHTML = '<span class="tiny">Live preview</span>';
        return;
      }
      renderRich(preview, value, { textAlign: align });
    }

    function wireLivePreview(inputId, previewId, getAlign = () => 'left') {
      const input = el(inputId);
      const preview = el(previewId);
      if (!input || !preview) return;
      const render = () => setPreview(previewId, input.value, getAlign());
      const debounced = debounce(render, 300);
      input.addEventListener('input', debounced);
      render();
    }

    function syncToolbarAlignmentButtons(group, align) {
      const normalized = normalizeTextAlign(align);
      document.querySelectorAll(`.text-toolbar [data-action="align"][data-group="${group}"]`).forEach(btn => {
        const active = btn.dataset.align === normalized;
        btn.classList.toggle('active', active);
        btn.setAttribute('aria-pressed', active ? 'true' : 'false');
      });
    }

    function applyCreateQuestionTextAlign(align) {
      createQuestionTextAlign = normalizeTextAlign(align);
      syncToolbarAlignmentButtons('create-question', createQuestionTextAlign);
      setPreview('questionPreview', el('cardPrompt')?.value || '', createQuestionTextAlign);
    }

    function applyCreateAnswerTextAlign(align) {
      createAnswerTextAlign = normalizeTextAlign(align);
      syncToolbarAlignmentButtons('create-answer', createAnswerTextAlign);
      setPreview('answerPreview', el('cardAnswer')?.value || '', createAnswerTextAlign);
    }

    function applyEditQuestionTextAlign(align) {
      editQuestionTextAlign = normalizeTextAlign(align);
      syncToolbarAlignmentButtons('edit-question', editQuestionTextAlign);
      setPreview('editQuestionPreview', el('editCardPrompt')?.value || '', editQuestionTextAlign);
    }

    function applyEditAnswerTextAlign(align) {
      editAnswerTextAlign = normalizeTextAlign(align);
      syncToolbarAlignmentButtons('edit-answer', editAnswerTextAlign);
      setPreview('editAnswerPreview', el('editCardAnswer')?.value || '', editAnswerTextAlign);
    }

    function applyCreateOptionsTextAlign(align) {
      createOptionsTextAlign = normalizeTextAlign(align);
      syncToolbarAlignmentButtons('create-options', createOptionsTextAlign);
    }

    function applyEditOptionsTextAlign(align) {
      editOptionsTextAlign = normalizeTextAlign(align);
      syncToolbarAlignmentButtons('edit-options', editOptionsTextAlign);
    }

    function ensureListInputLeftAligned(textarea) {
      if (!(textarea instanceof HTMLTextAreaElement)) return;
      if (textarea.id === 'cardPrompt') applyCreateQuestionTextAlign('left');
      else if (textarea.id === 'cardAnswer') applyCreateAnswerTextAlign('left');
      else if (textarea.id === 'editCardPrompt') applyEditQuestionTextAlign('left');
      else if (textarea.id === 'editCardAnswer') applyEditAnswerTextAlign('left');
    }

    function emitTextareaInput(textarea) {
      if (!textarea) return;
      textarea.dispatchEvent(new Event('input', { bubbles: true }));
    }

    function toggleInlineFormat(textarea, format = 'bold') {
      if (!textarea) return;
      const markers = { bold: '**', italic: '*', underline: '__' };
      const marker = markers[format];
      if (!marker) return;

      const value = textarea.value || '';
      const start = textarea.selectionStart ?? 0;
      const end = textarea.selectionEnd ?? start;
      const selected = value.slice(start, end);

      if (start === end) {
        const insert = `${marker}${marker}`;
        textarea.setRangeText(insert, start, end, 'end');
        const caret = start + marker.length;
        textarea.setSelectionRange(caret, caret);
        textarea.focus();
        emitTextareaInput(textarea);
        return;
      }

      const wrappedSelection = selected.startsWith(marker) && selected.endsWith(marker) && selected.length >= marker.length * 2;
      const wrappedAroundSelection = start >= marker.length
        && value.slice(start - marker.length, start) === marker
        && value.slice(end, end + marker.length) === marker;

      if (wrappedSelection) {
        const unwrapped = selected.slice(marker.length, selected.length - marker.length);
        textarea.setRangeText(unwrapped, start, end, 'end');
        textarea.setSelectionRange(start, start + unwrapped.length);
      } else if (wrappedAroundSelection) {
        textarea.setRangeText(selected, start - marker.length, end + marker.length, 'end');
        const nextStart = start - marker.length;
        textarea.setSelectionRange(nextStart, nextStart + selected.length);
      } else {
        const wrapped = `${marker}${selected}${marker}`;
        textarea.setRangeText(wrapped, start, end, 'end');
        textarea.setSelectionRange(start + marker.length, start + marker.length + selected.length);
      }

      textarea.focus();
      emitTextareaInput(textarea);
    }

    function toggleListPrefix(textarea, listType = 'ul') {
      if (!textarea) return;
      ensureListInputLeftAligned(textarea);
      const value = textarea.value || '';
      const start = textarea.selectionStart ?? 0;
      const end = textarea.selectionEnd ?? start;
      const lineStart = value.lastIndexOf('\n', Math.max(0, start - 1)) + 1;
      const lineEndIdx = value.indexOf('\n', end);
      const lineEnd = lineEndIdx === -1 ? value.length : lineEndIdx;
      const line = value.slice(lineStart, lineEnd);
      const meta = parseListLineMeta(line);
      const indent = (line.match(/^\s*/) || [''])[0];
      const content = line.slice(indent.length);
      const plainText = meta ? meta.text : content;

      let nextLine = line;
      if (listType === 'ol') {
        if (meta?.type === 'ol') nextLine = meta.indent + plainText;
        else nextLine = indent + '1. ' + plainText;
      } else {
        if (meta?.type === 'ul') nextLine = meta.indent + plainText;
        else nextLine = indent + '- ' + plainText;
      }

      textarea.setRangeText(nextLine, lineStart, lineEnd, 'end');
      textarea.focus();
      emitTextareaInput(textarea);
    }

    function getTableTargetLabel(targetId = '') {
      const map = {
        cardPrompt: 'Question',
        cardAnswer: 'Answer',
        editCardPrompt: 'Edit Question',
        editCardAnswer: 'Edit Answer'
      };
      return map[targetId] || 'Question';
    }

    function clampTableRows(value = 3) {
      return Math.max(1, Math.min(20, Math.trunc(Number(value) || 3)));
    }

    function clampTableCols(value = 3) {
      return Math.max(1, Math.min(10, Math.trunc(Number(value) || 3)));
    }

    function normalizeTableCellAlign(value = '') {
      const v = String(value || '').toLowerCase();
      if (v === 'center' || v === 'right') return v;
      return 'left';
    }

    function resizeTableGrid(source = [], rows = 1, cols = 1) {
      const safeSource = Array.isArray(source) ? source : [];
      return Array.from({ length: rows }, (_, rowIdx) => {
        const prevRow = Array.isArray(safeSource[rowIdx]) ? safeSource[rowIdx] : [];
        return Array.from({ length: cols }, (_, colIdx) => String(prevRow[colIdx] ?? ''));
      });
    }

    function resizeTableAlignmentGrid(source = [], rows = 1, cols = 1) {
      const safeSource = Array.isArray(source) ? source : [];
      return Array.from({ length: rows }, (_, rowIdx) => {
        const prevRow = Array.isArray(safeSource[rowIdx]) ? safeSource[rowIdx] : [];
        return Array.from({ length: cols }, (_, colIdx) => normalizeTableCellAlign(prevRow[colIdx] ?? 'left'));
      });
    }

    function normalizeTableBuilderState(next = {}) {
      const rows = clampTableRows(next.rows ?? tableBuilderState.rows);
      const cols = clampTableCols(next.cols ?? tableBuilderState.cols);
      const withHeader = typeof next.withHeader === 'boolean'
        ? next.withHeader
        : !!tableBuilderState.withHeader;
      const headerSource = Array.isArray(next.header) ? [next.header] : [tableBuilderState.header];
      const bodySource = Array.isArray(next.body) ? next.body : tableBuilderState.body;
      const headerAlignSource = Array.isArray(next.headerAlign) ? [next.headerAlign] : [tableBuilderState.headerAlign];
      const bodyAlignSource = Array.isArray(next.bodyAlign) ? next.bodyAlign : tableBuilderState.bodyAlign;
      const header = resizeTableGrid(headerSource, 1, cols)[0];
      const body = resizeTableGrid(bodySource, rows, cols);
      const headerAlign = resizeTableAlignmentGrid(headerAlignSource, 1, cols)[0];
      const bodyAlign = resizeTableAlignmentGrid(bodyAlignSource, rows, cols);
      tableBuilderState = { rows, cols, withHeader, header, body, headerAlign, bodyAlign };
      return tableBuilderState;
    }

    function getTableBuilderCellAlign(zone = 'body', row = 0, col = 0) {
      const state = normalizeTableBuilderState();
      if (zone === 'header') return normalizeTableCellAlign(state.headerAlign[col] || 'left');
      return normalizeTableCellAlign(state.bodyAlign[row]?.[col] || 'left');
    }

    function setTableBuilderCellAlign(zone = 'body', row = 0, col = 0, align = 'left') {
      const state = normalizeTableBuilderState();
      const safeAlign = normalizeTableCellAlign(align);
      if (zone === 'header') {
        if (col < 0 || col >= state.cols) return;
        state.headerAlign[col] = safeAlign;
      } else {
        if (row < 0 || row >= state.rows || col < 0 || col >= state.cols) return;
        state.bodyAlign[row][col] = safeAlign;
      }
    }

    function getTableBuilderSelection() {
      const state = normalizeTableBuilderState();
      if (!tableBuilderSelection) return null;
      const zone = tableBuilderSelection.zone === 'header' ? 'header' : 'body';
      const row = Math.max(0, Number(tableBuilderSelection.row || 0));
      const col = Math.max(0, Number(tableBuilderSelection.col || 0));
      if (col >= state.cols) return null;
      if (zone === 'header' && !state.withHeader) return null;
      if (zone === 'body' && row >= state.rows) return null;
      return { zone, row, col };
    }

    function setTableBuilderSelection(zone = 'body', row = 0, col = 0) {
      const state = normalizeTableBuilderState();
      const safeZone = zone === 'header' ? 'header' : 'body';
      const safeRow = Math.max(0, Number(row || 0));
      const safeCol = Math.max(0, Number(col || 0));
      if (safeCol >= state.cols) return;
      if (safeZone === 'header') {
        if (!state.withHeader) return;
        tableBuilderSelection = { zone: 'header', row: 0, col: safeCol };
      } else {
        if (safeRow >= state.rows) return;
        tableBuilderSelection = { zone: 'body', row: safeRow, col: safeCol };
      }
      syncTableBuilderAlignmentButtons();
      syncTableBuilderSelectionLabel();
    }

    function ensureTableBuilderSelection() {
      const state = normalizeTableBuilderState();
      const current = getTableBuilderSelection();
      if (current) return current;
      if (!state.rows || !state.cols) {
        tableBuilderSelection = null;
        return null;
      }
      tableBuilderSelection = state.withHeader
        ? { zone: 'header', row: 0, col: 0 }
        : { zone: 'body', row: 0, col: 0 };
      return getTableBuilderSelection();
    }

    function syncTableBuilderAlignmentButtons() {
      const selection = ensureTableBuilderSelection();
      const selectedAlign = selection
        ? getTableBuilderCellAlign(selection.zone, selection.row, selection.col)
        : null;
      document.querySelectorAll('.table-builder-align-btn').forEach(btn => {
        const align = normalizeTableCellAlign(btn.dataset.align || 'left');
        const isActive = !!selectedAlign && selectedAlign === align;
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      });
    }

    function syncTableBuilderSelectionLabel() {
      const label = el('tableCellSelectionLabel');
      if (!label) return;
      const selection = ensureTableBuilderSelection();
      if (!selection) {
        label.textContent = 'Cell: none selected';
        return;
      }
      if (selection.zone === 'header') {
        label.textContent = `Cell: Header ${selection.col + 1}`;
        return;
      }
      label.textContent = `Cell: R${selection.row + 1} C${selection.col + 1}`;
    }

    function applyTableBuilderInputAlign(input, align = 'left') {
      if (!(input instanceof HTMLInputElement)) return;
      const safeAlign = normalizeTableCellAlign(align);
      input.classList.remove('table-align-left', 'table-align-center', 'table-align-right');
      input.classList.add(`table-align-${safeAlign}`);
    }

    function syncTableBuilderControls() {
      const rowsInput = el('tableRowsInput');
      const colsInput = el('tableColsInput');
      const headerToggle = el('tableHeaderToggle');
      const state = normalizeTableBuilderState();
      if (rowsInput) rowsInput.value = String(state.rows);
      if (colsInput) colsInput.value = String(state.cols);
      if (headerToggle) headerToggle.checked = !!state.withHeader;
    }

    function createTableBuilderInput(zone = 'body', row = 0, col = 0, value = '', align = 'left') {
      const input = document.createElement('input');
      input.type = 'text';
      input.autocomplete = 'off';
      input.className = 'table-builder-cell-input';
      input.dataset.zone = zone;
      input.dataset.row = String(row);
      input.dataset.col = String(col);
      input.placeholder = zone === 'header' ? `Header ${col + 1}` : `R${row + 1}C${col + 1}`;
      input.value = value;
      applyTableBuilderInputAlign(input, align);
      return input;
    }

    function renderTableBuilderGrid() {
      const container = el('tableBuilderGrid');
      if (!container) return;
      const state = normalizeTableBuilderState();
      container.innerHTML = '';

      const sheet = document.createElement('table');
      sheet.className = 'table-builder-sheet';

      if (state.withHeader) {
        const thead = document.createElement('thead');
        const tr = document.createElement('tr');
        state.header.forEach((cellValue, colIdx) => {
          const th = document.createElement('th');
          th.appendChild(createTableBuilderInput('header', 0, colIdx, cellValue, state.headerAlign[colIdx]));
          tr.appendChild(th);
        });
        thead.appendChild(tr);
        sheet.appendChild(thead);
      }

      const tbody = document.createElement('tbody');
      state.body.forEach((rowValues, rowIdx) => {
        const tr = document.createElement('tr');
        rowValues.forEach((cellValue, colIdx) => {
          const td = document.createElement('td');
          td.appendChild(createTableBuilderInput('body', rowIdx, colIdx, cellValue, state.bodyAlign[rowIdx][colIdx]));
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      sheet.appendChild(tbody);
      container.appendChild(sheet);
      syncTableBuilderAlignmentButtons();
      syncTableBuilderSelectionLabel();
    }

    function updateTableBuilderFromControls() {
      const rowsInput = el('tableRowsInput');
      const colsInput = el('tableColsInput');
      const headerToggle = el('tableHeaderToggle');
      normalizeTableBuilderState({
        rows: clampTableRows(rowsInput?.value),
        cols: clampTableCols(colsInput?.value),
        withHeader: !!headerToggle?.checked
      });
      syncTableBuilderControls();
      renderTableBuilderGrid();
    }

    function stepTableBuilderSize(axis = 'rows', delta = 1) {
      const state = normalizeTableBuilderState();
      if (axis === 'cols') {
        normalizeTableBuilderState({ cols: clampTableCols(state.cols + delta) });
      } else {
        normalizeTableBuilderState({ rows: clampTableRows(state.rows + delta) });
      }
      syncTableBuilderControls();
      renderTableBuilderGrid();
    }

    function handleTableBuilderInput(e) {
      const target = e.target;
      if (!(target instanceof HTMLInputElement) || !target.classList.contains('table-builder-cell-input')) return;
      const zone = target.dataset.zone || 'body';
      const row = Math.max(0, Number(target.dataset.row || 0));
      const col = Math.max(0, Number(target.dataset.col || 0));
      const value = String(target.value || '');
      const state = normalizeTableBuilderState();
      if (zone === 'header') {
        if (col < state.cols) state.header[col] = value;
      } else if (row < state.rows && col < state.cols) {
        state.body[row][col] = value;
      }
    }

    function handleTableBuilderSelection(e) {
      const target = e.target;
      if (!(target instanceof HTMLInputElement) || !target.classList.contains('table-builder-cell-input')) return;
      const zone = target.dataset.zone || 'body';
      const row = Math.max(0, Number(target.dataset.row || 0));
      const col = Math.max(0, Number(target.dataset.col || 0));
      setTableBuilderSelection(zone, row, col);
    }

    function applyTableBuilderSelectedAlignment(align = 'left') {
      const selection = ensureTableBuilderSelection();
      if (!selection) return;
      const safeAlign = normalizeTableCellAlign(align);
      setTableBuilderCellAlign(selection.zone, selection.row, selection.col, safeAlign);
      const input = document.querySelector(
        `.table-builder-cell-input[data-zone="${selection.zone}"][data-row="${selection.row}"][data-col="${selection.col}"]`
      );
      applyTableBuilderInputAlign(input, safeAlign);
      syncTableBuilderAlignmentButtons();
    }

    function escapeMarkdownTableCell(value = '') {
      return String(value || '').replace(/\r?\n/g, ' ').replace(/\|/g, '\\|').trim();
    }

    function encodeMarkdownTableCell(value = '', align = 'left') {
      const text = escapeMarkdownTableCell(value);
      const safeAlign = normalizeTableCellAlign(align);
      if (safeAlign === 'left') return text;
      return `[[align:${safeAlign}]] ${text}`.trim();
    }

    function buildMarkdownTableFromState() {
      const state = normalizeTableBuilderState();
      const cols = state.cols;
      const headerCells = state.withHeader
        ? state.header.map((value, idx) => encodeMarkdownTableCell(value, state.headerAlign[idx]))
        : Array.from({ length: cols }, () => '');
      const lines = [
        `| ${headerCells.join(' | ')} |`,
        `| ${Array.from({ length: cols }, () => '---').join(' | ')} |`
      ];
      state.body.forEach((row, rowIdx) => {
        lines.push(`| ${row.map((value, colIdx) => encodeMarkdownTableCell(value, state.bodyAlign[rowIdx][colIdx])).join(' | ')} |`);
      });
      return lines.join('\n');
    }

    function insertGeneratedTableIntoTextarea(textarea, tableMarkdown = '') {
      if (!(textarea instanceof HTMLTextAreaElement)) return;
      const tableText = String(tableMarkdown || '').trim();
      if (!tableText) return;
      ensureListInputLeftAligned(textarea);
      const value = textarea.value || '';
      const start = textarea.selectionStart ?? value.length;
      const end = textarea.selectionEnd ?? start;
      const needsLeadingBreak = start > 0 && value[start - 1] !== '\n';
      const needsTrailingBreak = end < value.length && value[end] !== '\n';
      const prefix = needsLeadingBreak ? '\n' : '';
      const suffix = needsTrailingBreak ? '\n' : '';
      const insertText = `${prefix}${tableText}${suffix}`;
      textarea.setRangeText(insertText, start, end, 'end');
      const caret = start + insertText.length;
      textarea.setSelectionRange(caret, caret);
      textarea.focus();
      emitTextareaInput(textarea);
    }

    function openTableDialog(targetId = '') {
      const dialog = el('tableDialog');
      if (!dialog) return;
      tableTarget = targetId || 'cardPrompt';
      const targetLabel = el('tableTargetLabel');
      if (targetLabel) targetLabel.textContent = `Target: ${getTableTargetLabel(tableTarget)}`;
      normalizeTableBuilderState({
        rows: 3,
        cols: 3,
        withHeader: true,
        header: [],
        body: [],
        headerAlign: [],
        bodyAlign: []
      });
      tableBuilderSelection = { zone: 'header', row: 0, col: 0 };
      syncTableBuilderControls();
      renderTableBuilderGrid();
      showDialog(dialog);
      setTimeout(() => {
        const preferredSelector = tableBuilderSelection
          ? `.table-builder-cell-input[data-zone="${tableBuilderSelection.zone}"][data-row="${tableBuilderSelection.row}"][data-col="${tableBuilderSelection.col}"]`
          : '.table-builder-cell-input';
        const preferredCell = dialog.querySelector(preferredSelector);
        const firstCell = preferredCell || dialog.querySelector('.table-builder-cell-input');
        if (firstCell instanceof HTMLInputElement) {
          firstCell.focus();
          firstCell.select();
        }
      }, 0);
    }

    function insertTableFromDialog() {
      const textarea = el(tableTarget || '');
      if (!(textarea instanceof HTMLTextAreaElement)) return;
      const tableMarkdown = buildMarkdownTableFromState();
      insertGeneratedTableIntoTextarea(textarea, tableMarkdown);
      closeDialog(el('tableDialog'));
    }

    function handleListAutoIndent(e) {
      if (e.key !== 'Enter' || e.shiftKey || e.ctrlKey || e.metaKey || e.altKey) return;
      const textarea = e.target;
      if (!(textarea instanceof HTMLTextAreaElement)) return;
      const start = textarea.selectionStart ?? 0;
      const end = textarea.selectionEnd ?? start;
      if (start !== end) return;

      const value = textarea.value || '';
      const lineStart = value.lastIndexOf('\n', Math.max(0, start - 1)) + 1;
      const lineEndIdx = value.indexOf('\n', start);
      const lineEnd = lineEndIdx === -1 ? value.length : lineEndIdx;
      const line = value.slice(lineStart, lineEnd);
      const listMeta = parseListLineMeta(line);
      if (!listMeta) return;

      e.preventDefault();
      ensureListInputLeftAligned(textarea);
      let insert = '\n';
      if (!listMeta.text.trim()) {
        insert = '\n';
      } else if (listMeta.type === 'ul') {
        insert = `\n${listMeta.indent}${listMeta.marker || '-'} `;
      } else if (listMeta.type === 'ol') {
        const nextSequence = [...listMeta.sequence];
        nextSequence[nextSequence.length - 1] = (nextSequence[nextSequence.length - 1] || 0) + 1;
        insert = `\n${listMeta.indent}${formatOrderedSequence(nextSequence)} `;
      }
      textarea.setRangeText(insert, start, end, 'end');
      emitTextareaInput(textarea);
    }

    function handleListTabIndent(e) {
      if (e.key !== 'Tab' || e.ctrlKey || e.metaKey || e.altKey) return;
      const textarea = e.target;
      if (!(textarea instanceof HTMLTextAreaElement)) return;

      if (textarea.id === 'cardPrompt' && !e.shiftKey) {
        e.preventDefault();
        const answerField = el('cardAnswer');
        if (!(answerField instanceof HTMLTextAreaElement)) return;
        answerField.focus();
        const caret = answerField.value.length;
        answerField.setSelectionRange(caret, caret);
        return;
      }

      const start = textarea.selectionStart ?? 0;
      const end = textarea.selectionEnd ?? start;
      if (start !== end) return;

      const value = textarea.value || '';
      const lineStart = value.lastIndexOf('\n', Math.max(0, start - 1)) + 1;
      const lineEndIdx = value.indexOf('\n', start);
      const lineEnd = lineEndIdx === -1 ? value.length : lineEndIdx;
      const line = value.slice(lineStart, lineEnd);
      const listMeta = parseListLineMeta(line);
      if (!listMeta) return;

      e.preventDefault();
      ensureListInputLeftAligned(textarea);
      let nextLine = line;
      if (e.shiftKey) {
        const outdentedIndent = listMeta.indent.slice(0, Math.max(0, listMeta.indent.length - 2));
        if (listMeta.type === 'ol') {
          const outdentedSequence = listMeta.sequence.length > 1
            ? listMeta.sequence.slice(0, -1)
            : listMeta.sequence;
          nextLine = `${outdentedIndent}${formatOrderedSequence(outdentedSequence)} ${listMeta.text || ''}`;
        } else {
          const outdentedMarker = getOutdentedBulletMarker(listMeta.marker || '-');
          nextLine = `${outdentedIndent}${outdentedMarker} ${listMeta.text || ''}`;
        }
      } else {
        const nestedIndent = `${listMeta.indent}  `;
        if (listMeta.type === 'ol') {
          const prevMeta = getPreviousNonEmptyLineMeta(value, lineStart);
          let parentSequence = listMeta.sequence.length > 1
            ? listMeta.sequence.slice(0, -1)
            : listMeta.sequence.slice();
          if (prevMeta?.type === 'ol' && prevMeta.sequence.length) {
            parentSequence = prevMeta.sequence.slice();
          }
          const nestedSequence = [...parentSequence, 1];
          nextLine = `${nestedIndent}${formatOrderedSequence(nestedSequence)} ${listMeta.text || ''}`;
        } else {
          const nestedMarker = getNestedBulletMarker(listMeta.marker || '-');
          nextLine = `${nestedIndent}${nestedMarker} ${listMeta.text || ''}`;
        }
      }

      textarea.setRangeText(nextLine, lineStart, lineEnd, 'end');
      const nextCaret = Math.min(lineStart + nextLine.length, textarea.value.length);
      textarea.setSelectionRange(nextCaret, nextCaret);
      emitTextareaInput(textarea);
    }

    function handleInlineFormatShortcut(e) {
      if (e.shiftKey || e.altKey || !(e.metaKey || e.ctrlKey)) return;
      const textarea = e.target;
      if (!(textarea instanceof HTMLTextAreaElement)) return;
      const key = String(e.key || '').toLowerCase();
      if (key === 'b') {
        e.preventDefault();
        toggleInlineFormat(textarea, 'bold');
      } else if (key === 'i') {
        e.preventDefault();
        toggleInlineFormat(textarea, 'italic');
      } else if (key === 'u') {
        e.preventDefault();
        toggleInlineFormat(textarea, 'underline');
      }
    }

    function applyTextareaAlignmentShortcut(textarea, align = 'left') {
      if (!(textarea instanceof HTMLTextAreaElement)) return;
      const targetAlign = normalizeTextAlign(align);
      if (textarea.id === 'cardPrompt') applyCreateQuestionTextAlign(targetAlign);
      else if (textarea.id === 'cardAnswer') applyCreateAnswerTextAlign(targetAlign);
      else if (textarea.id === 'editCardPrompt') applyEditQuestionTextAlign(targetAlign);
      else if (textarea.id === 'editCardAnswer') applyEditAnswerTextAlign(targetAlign);
    }

    function handleTextAlignShortcut(e) {
      if (e.shiftKey || e.altKey || !(e.metaKey || e.ctrlKey)) return;
      const textarea = e.target;
      if (!(textarea instanceof HTMLTextAreaElement)) return;
      const key = String(e.key || '').toLowerCase();
      if (key === 'l') {
        e.preventDefault();
        applyTextareaAlignmentShortcut(textarea, 'left');
      } else if (key === 'c') {
        const start = textarea.selectionStart ?? 0;
        const end = textarea.selectionEnd ?? start;
        if (end > start) return; // keep native Cmd/Ctrl+C copy when text is selected
        e.preventDefault();
        applyTextareaAlignmentShortcut(textarea, 'center');
      } else if (key === 'j') {
        e.preventDefault();
        applyTextareaAlignmentShortcut(textarea, 'justify');
      }
    }

    function wireTextFormattingToolbar() {
      document.querySelectorAll('.text-toolbar .toolbar-btn').forEach(btn => {
        btn.addEventListener('click', e => {
          e.preventDefault();
          const action = btn.dataset.action || '';
          if (action === 'align') {
            const group = btn.dataset.group || 'create-question';
            const align = normalizeTextAlign(btn.dataset.align || 'left');
            if (group === 'create-question') applyCreateQuestionTextAlign(align);
            else if (group === 'create-answer') applyCreateAnswerTextAlign(align);
            else if (group === 'edit-question') applyEditQuestionTextAlign(align);
            else if (group === 'edit-answer') applyEditAnswerTextAlign(align);
            else if (group === 'create-options') applyCreateOptionsTextAlign(align);
            else if (group === 'edit-options') applyEditOptionsTextAlign(align);
            else applyCreateQuestionTextAlign(align);
            return;
          }
          if (action === 'format') {
            const targetId = btn.dataset.target || '';
            const textarea = el(targetId);
            const format = btn.dataset.format || 'bold';
            toggleInlineFormat(textarea, format);
            return;
          }
          if (action === 'list') {
            const targetId = btn.dataset.target || '';
            const textarea = el(targetId);
            const listType = btn.dataset.list || 'ul';
            toggleListPrefix(textarea, listType);
            return;
          }
          if (action === 'table') {
            const targetId = btn.dataset.target || '';
            openTableDialog(targetId);
          }
        });
      });

      ['cardPrompt', 'cardAnswer', 'editCardPrompt', 'editCardAnswer'].forEach(id => {
        const textarea = el(id);
        if (!textarea) return;
        textarea.addEventListener('keydown', handleListTabIndent);
        textarea.addEventListener('keydown', handleListAutoIndent);
        textarea.addEventListener('keydown', handleInlineFormatShortcut);
        textarea.addEventListener('keydown', handleTextAlignShortcut);
      });

      syncToolbarAlignmentButtons('create-question', createQuestionTextAlign);
      syncToolbarAlignmentButtons('create-answer', createAnswerTextAlign);
      syncToolbarAlignmentButtons('edit-question', editQuestionTextAlign);
      syncToolbarAlignmentButtons('edit-answer', editAnswerTextAlign);
      syncToolbarAlignmentButtons('create-options', createOptionsTextAlign);
      syncToolbarAlignmentButtons('edit-options', editOptionsTextAlign);
    }

    const HTML2CANVAS_URL = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
    let html2canvasLoading = null;
    let katexCssCache = null;
    function ensureHtml2Canvas() {
      if (window.html2canvas) return Promise.resolve();
      if (html2canvasLoading) return html2canvasLoading;
      html2canvasLoading = new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = HTML2CANVAS_URL;
        script.onload = () => resolve();
        script.onerror = () => reject(new Error('Failed to load html2canvas'));
        document.head.appendChild(script);
      });
      return html2canvasLoading;
    }

    function ensureStylesheetLoaded(url) {
      if (!url) return;
      if (document.querySelector(`link[rel="stylesheet"][href="${url}"]`)) return;
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = url;
      document.head.appendChild(link);
    }

    function loadScriptOnce(url) {
      if (!url) return Promise.reject(new Error('Missing script URL'));
      if (scriptLoadCache.has(url)) return scriptLoadCache.get(url);
      const promise = new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = url;
        script.async = true;
        script.onload = () => resolve();
        script.onerror = () => {
          scriptLoadCache.delete(url);
          reject(new Error(`Failed to load script: ${url}`));
        };
        document.head.appendChild(script);
      });
      scriptLoadCache.set(url, promise);
      return promise;
    }

    async function ensureKatexLoaded() {
      if (window.katex && window.renderMathInElement) return true;
      if (katexLoading) return katexLoading;
      katexLoading = (async () => {
        try {
          ensureStylesheetLoaded(KATEX_CSS_URL);
          if (!window.katex) await loadScriptOnce(KATEX_JS_URL);
          if (!window.renderMathInElement) await loadScriptOnce(KATEX_AUTORENDER_URL);
          return !!(window.katex && window.renderMathInElement);
        } catch (err) {
          return false;
        }
      })();
      const loaded = await katexLoading;
      if (!loaded) katexLoading = null;
      return loaded;
    }

    async function getKatexCssText() {
      if (katexCssCache !== null) return katexCssCache;
      const link = document.querySelector('link[href*="katex.min.css"]');
      const href = link?.href || KATEX_CSS_URL;
      try {
        const res = await fetch(href);
        katexCssCache = res.ok ? await res.text() : '';
      } catch (err) {
        katexCssCache = '';
      }
      return katexCssCache;
    }

    async function renderFormulaToSvgDataUrl(renderEl) {
      const css = await getKatexCssText();
      const rect = renderEl.getBoundingClientRect();
      const width = Math.max(10, Math.ceil(rect.width || 0));
      const height = Math.max(10, Math.ceil(rect.height || 0));
      const safeCss = (css || '').replace(/<\/style>/g, '<\\/style>');
      const html = renderEl.outerHTML;
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">
          <foreignObject width="100%" height="100%">
            <div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;">
              <style>${safeCss}</style>
              ${html}
            </div>
          </foreignObject>
        </svg>
      `;
      const encoded = btoa(unescape(encodeURIComponent(svg)));
      return `data:image/svg+xml;base64,${encoded}`;
    }

    const formulaTargets = {
      cardPrompt: { previewId: 'questionImagePreview', legacyKey: 'imageDataQ', label: 'Question' },
      cardAnswer: { previewId: 'answerImagePreview', legacyKey: 'imageDataA', label: 'Answer' },
      editCardPrompt: { previewId: 'editQuestionImagePreview', legacyKey: 'imageDataQ', label: 'Edit Question' },
      editCardAnswer: { previewId: 'editAnswerImagePreview', legacyKey: 'imageDataA', label: 'Edit Answer' }
    };

    function normalizeFormulaInput(raw, displayToggle) {
      const t = (raw || '').trim();
      if (!t) return { text: '', display: !!displayToggle?.checked, detected: null };
      if (t.startsWith('$$') && t.endsWith('$$') && t.length > 4) {
        return { text: t.slice(2, -2).trim(), display: true, detected: true };
      }
      if (t.startsWith('\\[') && t.endsWith('\\]') && t.length > 4) {
        return { text: t.slice(2, -2).trim(), display: true, detected: true };
      }
      if (t.startsWith('$') && t.endsWith('$') && t.length > 2) {
        return { text: t.slice(1, -1).trim(), display: false, detected: false };
      }
      if (t.startsWith('\\(') && t.endsWith('\\)') && t.length > 4) {
        return { text: t.slice(2, -2).trim(), display: false, detected: false };
      }
      return { text: t, display: !!displayToggle?.checked, detected: null };
    }

    function renderFormulaPreview() {
      const input = el('formulaInput');
      const renderEl = el('formulaRender');
      const errorEl = el('formulaError');
      const displayToggle = el('formulaDisplayToggle');
      const insertBtn = el('insertFormulaBtn');
      if (!input || !renderEl || !displayToggle || !errorEl || !insertBtn) return;

      const { text, display, detected } = normalizeFormulaInput(input.value, displayToggle);
      if (detected !== null) displayToggle.checked = display;
      renderEl.innerHTML = '';
      errorEl.classList.add('hidden');
      insertBtn.disabled = !text;
      if (!text) return;

      if (!window.katex) {
        errorEl.textContent = 'Loading formula renderer...';
        errorEl.classList.remove('hidden');
        insertBtn.disabled = true;
        ensureKatexLoaded().then(loaded => {
          if (loaded) {
            renderFormulaPreview();
            return;
          }
          errorEl.textContent = 'Formula renderer not available.';
          errorEl.classList.remove('hidden');
          insertBtn.disabled = true;
        });
        return;
      }
      try {
        window.katex.render(text, renderEl, { displayMode: display, throwOnError: true });
      } catch (err) {
        errorEl.textContent = 'Invalid formula. Please check your LaTeX.';
        errorEl.classList.remove('hidden');
        insertBtn.disabled = true;
      }
    }

    async function insertFormulaImage() {
      const target = formulaTargets[formulaTarget];
      const input = el('formulaInput');
      const renderEl = el('formulaRender');
      const dialog = el('formulaDialog');
      if (!target || !input || !renderEl || !dialog) return;
      if (!input.value.trim()) return;
      renderFormulaPreview();
      let dataUrl = '';
      try {
        await ensureHtml2Canvas();
        if (window.html2canvas) {
          const canvas = await window.html2canvas(renderEl, { backgroundColor: null, scale: 2, useCORS: true });
          dataUrl = canvas.toDataURL('image/png');
        }
      } catch (err) {
        dataUrl = '';
      }
      if (!dataUrl) {
        dataUrl = await renderFormulaToSvgDataUrl(renderEl);
      }
      const targetField = el(formulaTarget);
      const previewEl = el(target.previewId);
      if (!targetField || !previewEl) return;

      const isCreateField = formulaTarget === 'cardPrompt' || formulaTarget === 'cardAnswer';
      appendImagesToField(
        targetField,
        previewEl,
        [dataUrl],
        target.legacyKey,
        () => { if (isCreateField) updateCreateValidation(); }
      );
      if (isCreateField) updateCreateValidation();
      dialog.close();
    }

    function openFormulaDialog(targetId) {
      const dialog = el('formulaDialog');
      const targetLabel = el('formulaTargetLabel');
      const input = el('formulaInput');
      const displayToggle = el('formulaDisplayToggle');
      if (!dialog || !input || !displayToggle) return;
      formulaTarget = targetId;
      const targetMeta = formulaTargets[targetId];
      if (targetLabel && targetMeta) targetLabel.textContent = `Target: ${targetMeta.label}`;
      input.value = '';
      displayToggle.checked = false;
      renderFormulaPreview();
      dialog.showModal();
    }

    function getCreateOptionCount() {
      const primaryText = el('cardAnswer').value.trim();
      let count = primaryText ? 1 : 0;
      Array.from(el('mcqOptions').querySelectorAll('.mcq-row[data-primary="false"] input[type="text"]'))
        .forEach(input => {
          if (input.value.trim()) count += 1;
        });
      return count;
    }

    function parseMcqOptions() {
      if (!mcqMode) return [];
      const options = [];
      const primaryText = el('cardAnswer').value.trim();
      const primaryToggle = el('primaryAnswerToggle');
      if (primaryText) {
        options.push({ text: primaryText, correct: primaryToggle ? primaryToggle.checked : true });
      }
      const rows = Array.from(el('mcqOptions').querySelectorAll('.mcq-row[data-primary="false"]'));
      rows.forEach(row => {
        const text = row.querySelector('input[type="text"]').value.trim();
        const correct = row.querySelector('.mcq-toggle input[type="checkbox"]').checked;
        if (text) options.push({ text, correct });
      });
      return options;
    }

    function addMcqRow(text = '', correct = false) {
      const wrap = document.createElement('div');
      wrap.className = `mcq-row ${correct ? 'correct' : 'wrong'}`;
      wrap.dataset.primary = 'false';
      wrap.innerHTML = `
        <div class="mcq-row-header">
          <span class="mcq-badge ${correct ? 'correct' : 'wrong'}">${correct ? 'Correct Answer ‚úì' : 'Wrong Answer ‚úï'}</span>
          <label class="toggle mcq-toggle">
            <input type="checkbox" ${correct ? 'checked' : ''} />
            <span class="toggle-slider"></span>
          </label>
        </div>
        <input type="text" placeholder="Answer option..." value="${escapeHTML(text)}" />
        <div class="mcq-row-actions">
          <div class="tiny">Additional answer option</div>
          <button class="btn mcq-remove" type="button">Remove</button>
        </div>
      `;
      const toggle = wrap.querySelector('.mcq-toggle input[type="checkbox"]');
      const update = () => {
        const isCorrect = toggle.checked;
        wrap.classList.toggle('correct', isCorrect);
        wrap.classList.toggle('wrong', !isCorrect);
        const badge = wrap.querySelector('.mcq-badge');
        badge.className = `mcq-badge ${isCorrect ? 'correct' : 'wrong'}`;
        badge.textContent = isCorrect ? 'Correct Answer ‚úì' : 'Wrong Answer ‚úï';
      };
      toggle.addEventListener('change', update);
      const input = wrap.querySelector('input[type="text"]');
      if (input) input.addEventListener('input', () => updateCreateValidation());
      wrap.querySelector('.mcq-remove').onclick = () => {
        wrap.remove();
        syncMcqPrimaryAnswerMode(false);
      };
      update();
      el('mcqOptions').appendChild(wrap);
    }

    function parseEditMcqOptions() {
      if (!editMcqMode) return [];
      const options = [];
      const primaryText = el('editCardAnswer').value.trim();
      const primaryToggle = el('editPrimaryAnswerToggle');
      if (primaryText) {
        options.push({ text: primaryText, correct: primaryToggle ? primaryToggle.checked : true });
      }
      const rows = Array.from(el('editMcqOptions').querySelectorAll('.mcq-row[data-primary="false"]'));
      rows.forEach(row => {
        const text = row.querySelector('input[type="text"]').value.trim();
        const correct = row.querySelector('.mcq-toggle input[type="checkbox"]').checked;
        if (text) options.push({ text, correct });
      });
      return options;
    }

    function addEditMcqRow(text = '', correct = false) {
      const wrap = document.createElement('div');
      wrap.className = `mcq-row ${correct ? 'correct' : 'wrong'}`;
      wrap.dataset.primary = 'false';
      wrap.innerHTML = `
        <div class="mcq-row-header">
          <span class="mcq-badge ${correct ? 'correct' : 'wrong'}">${correct ? 'Correct Answer ‚úì' : 'Wrong Answer ‚úï'}</span>
          <label class="toggle mcq-toggle">
            <input type="checkbox" ${correct ? 'checked' : ''} />
            <span class="toggle-slider"></span>
          </label>
        </div>
        <input type="text" placeholder="Answer option..." value="${escapeHTML(text)}" />
        <div class="mcq-row-actions">
          <div class="tiny">Additional answer option</div>
          <button class="btn mcq-remove" type="button">Remove</button>
        </div>
      `;
      const toggle = wrap.querySelector('.mcq-toggle input[type="checkbox"]');
      const update = () => {
        const isCorrect = toggle.checked;
        wrap.classList.toggle('correct', isCorrect);
        wrap.classList.toggle('wrong', !isCorrect);
        const badge = wrap.querySelector('.mcq-badge');
        badge.className = `mcq-badge ${isCorrect ? 'correct' : 'wrong'}`;
        badge.textContent = isCorrect ? 'Correct Answer ‚úì' : 'Wrong Answer ‚úï';
      };
      toggle.addEventListener('change', update);
      wrap.querySelector('.mcq-remove').onclick = () => {
        wrap.remove();
        syncMcqPrimaryAnswerMode(true);
      };
      update();
      el('editMcqOptions').appendChild(wrap);
    }

    function openEditDialog(card) {
      editingCardId = card.id;
      const questionAlign = card.questionTextAlign || card.textAlign || 'center';
      const answerAlign = card.answerTextAlign || card.textAlign || 'center';
      applyEditQuestionTextAlign(questionAlign);
      applyEditAnswerTextAlign(answerAlign);
      applyEditOptionsTextAlign(card.optionsTextAlign || 'left');
      el('editCardPrompt').value = card.prompt || '';
      el('editCardAnswer').value = card.answer || '';
      replaceFieldImages(
        el('editCardPrompt'),
        el('editQuestionImagePreview'),
        getCardImageList(card, 'Q'),
        'imageDataQ'
      );
      replaceFieldImages(
        el('editCardAnswer'),
        el('editAnswerImagePreview'),
        getCardImageList(card, 'A'),
        'imageDataA'
      );
      setPreview('editQuestionPreview', el('editCardPrompt').value || '', editQuestionTextAlign);
      setPreview('editAnswerPreview', el('editCardAnswer').value || '', editAnswerTextAlign);
      el('editMcqOptions').innerHTML = '';
      const opts = card.options || [];
      const hasMcq = card.type === 'mcq' && opts.length > 1;
      setMcqModeState(true, hasMcq);
      if (hasMcq) {
        const primaryText = (el('editCardAnswer').value || '').trim();
        let primaryIdx = opts.findIndex(opt => (opt.text || '').trim() === primaryText);
        if (primaryIdx === -1) primaryIdx = 0;
        const primaryOpt = opts[primaryIdx];
        const toggle = el('editPrimaryAnswerToggle');
        if (toggle && primaryOpt) toggle.checked = !!primaryOpt.correct;
        syncPrimaryMcqUi(true);
        opts.forEach((opt, i) => {
          if (i === primaryIdx) return;
          addEditMcqRow(opt.text, opt.correct);
        });
      }
      syncMcqPrimaryAnswerMode(true);
      el('editCardDialog').showModal();
    }

    async function deleteCardById(cardId, options = {}) {
      const { skipSubjectTouch = false } = options;
      const card = await getById('cards', cardId);
      await del('cards', cardId);
      await del('progress', cardId);
      await del('cardbank', cardId);
      progressByCardId.delete(cardId);
      if (!skipSubjectTouch && card?.topicId) {
        await touchSubjectByTopicId(card.topicId);
      }
      if (session.active) {
        session.activeQueue = session.activeQueue.filter(c => c.id !== cardId);
        session.mastered = session.mastered.filter(c => c.id !== cardId);
        delete session.counts[cardId];
        delete session.gradeMap[cardId];
        renderSessionPills();
        renderSessionCard();
      }
    }

    function getDeckSelectionIds() {
      return Array.from(deckSelectedCardIds);
    }

    function updateDeckSelectionUi() {
      const toggleBtn = el('toggleCardSelectBtn');
      const bulkBar = el('deckBulkActions');
      const count = el('deckSelectionCount');
      const moveBtn = el('moveSelectedCardsBtn');
      const deleteBtn = el('deleteSelectedCardsBtn');
      const hasSelection = deckSelectedCardIds.size > 0;

      if (toggleBtn) {
        toggleBtn.classList.toggle('active', deckSelectionMode);
        toggleBtn.setAttribute('aria-pressed', deckSelectionMode ? 'true' : 'false');
      }
      if (bulkBar) {
        bulkBar.classList.toggle('hidden', !deckSelectionMode);
      }
      if (count) {
        count.textContent = `${deckSelectedCardIds.size} ausgewaehlt`;
      }
      if (moveBtn) moveBtn.disabled = !hasSelection;
      if (deleteBtn) deleteBtn.disabled = !hasSelection;
    }

    function setDeckSelectionMode(enabled) {
      deckSelectionMode = !!enabled;
      if (!deckSelectionMode) deckSelectedCardIds.clear();
      updateDeckSelectionUi();
    }

    function toggleDeckCardSelection(cardId, forceState = null) {
      const next = forceState === null ? !deckSelectedCardIds.has(cardId) : !!forceState;
      if (next) deckSelectedCardIds.add(cardId);
      else deckSelectedCardIds.delete(cardId);
      updateDeckSelectionUi();
    }

    function getTopicSelectionIds() {
      return Array.from(topicSelectedIds);
    }

    function updateTopicSelectionUi() {
      const toggleBtn = el('toggleTopicSelectBtn');
      const bulkBar = el('topicBulkActions');
      const count = el('topicSelectionCount');
      const moveBtn = el('moveSelectedTopicsBtn');
      const deleteBtn = el('deleteSelectedTopicsBtn');
      const hasSelection = topicSelectedIds.size > 0;

      if (toggleBtn) {
        toggleBtn.classList.toggle('active', topicSelectionMode);
        toggleBtn.setAttribute('aria-pressed', topicSelectionMode ? 'true' : 'false');
      }
      if (bulkBar) {
        bulkBar.classList.toggle('hidden', !topicSelectionMode);
      }
      if (count) {
        const word = topicSelectedIds.size === 1 ? 'topic' : 'topics';
        count.textContent = `${topicSelectedIds.size} ${word} selected`;
      }
      if (moveBtn) moveBtn.disabled = !hasSelection;
      if (deleteBtn) deleteBtn.disabled = !hasSelection;
    }

    function setTopicSelectionMode(enabled) {
      topicSelectionMode = !!enabled;
      if (!topicSelectionMode) topicSelectedIds.clear();
      updateTopicSelectionUi();
    }

    function toggleTopicSelection(topicId, forceState = null) {
      const next = forceState === null ? !topicSelectedIds.has(topicId) : !!forceState;
      if (next) topicSelectedIds.add(topicId);
      else topicSelectedIds.delete(topicId);
      updateTopicSelectionUi();
    }

    async function openMoveTopicsDialog() {
      const ids = getTopicSelectionIds();
      if (!ids.length) {
        alert('Please select topics first.');
        return;
      }
      const subjectSelect = el('moveTopicsSubjectSelect');
      const info = el('moveTopicsSelectionInfo');
      const confirmBtn = el('confirmMoveTopicsBtn');
      if (!subjectSelect || !confirmBtn) return;

      const subjects = sortSubjectsByLastEdited((await getAll('subjects')).filter(s => s.id !== selectedSubject?.id));
      subjectSelect.innerHTML = '';
      subjects.forEach(subject => {
        const option = document.createElement('option');
        option.value = subject.id;
        option.textContent = subject.name;
        subjectSelect.appendChild(option);
      });
      const hasTargets = subjects.length > 0;
      subjectSelect.disabled = !hasTargets;
      confirmBtn.disabled = !hasTargets;
      if (info) {
        const word = ids.length === 1 ? 'topic' : 'topics';
        info.textContent = `${ids.length} ${word} selected`;
      }
      if (!hasTargets) {
        alert('No other subject available as target.');
        return;
      }
      showDialog(el('moveTopicsDialog'));
    }

    async function moveSelectedTopics() {
      const ids = getTopicSelectionIds();
      if (!ids.length) return;
      const targetSubjectId = el('moveTopicsSubjectSelect')?.value || '';
      const sourceSubjectId = selectedSubject?.id || '';
      if (!targetSubjectId) {
        alert('Please select a target subject.');
        return;
      }
      const allTopics = await getAll('topics');
      for (const topic of allTopics) {
        if (!topicSelectedIds.has(topic.id)) continue;
        if (topic.subjectId === targetSubjectId) continue;
        await put('topics', { ...topic, subjectId: targetSubjectId });
        selectedTopicIds.delete(topic.id);
        if (selectedTopic?.id === topic.id) selectedTopic = null;
      }
      if (sourceSubjectId) await touchSubject(sourceSubjectId);
      if (targetSubjectId && targetSubjectId !== sourceSubjectId) await touchSubject(targetSubjectId);
      closeDialog(el('moveTopicsDialog'));
      setTopicSelectionMode(false);
      await refreshSidebar();
      await loadTopics();
      if (!selectedTopic && currentView === 2) {
        setDeckSelectionMode(false);
        session.active = false;
        el('cardsOverviewSection').classList.remove('hidden');
        el('studySessionSection')?.classList.add('hidden');
        renderSessionPills();
        setView(1);
      }
    }

    async function deleteSelectedTopics() {
      const ids = getTopicSelectionIds();
      if (!ids.length) return;
      const label = ids.length === 1 ? 'this topic' : `these ${ids.length} topics`;
      if (!confirm(`Delete ${label} and all cards inside?`)) return;
      for (const topicId of ids) {
        await deleteTopicById(topicId, { skipSubjectTouch: true });
      }
      if (selectedSubject?.id) await touchSubject(selectedSubject.id);
      setTopicSelectionMode(false);
      await refreshSidebar();
      await loadTopics();
      if (!selectedTopic && currentView === 2) {
        setDeckSelectionMode(false);
        session.active = false;
        el('cardsOverviewSection').classList.remove('hidden');
        el('studySessionSection')?.classList.add('hidden');
        renderSessionPills();
        setView(1);
      }
    }

    function syncSessionCard(updated) {
      if (!session.active || !updated) return;
      const activeIdx = session.activeQueue.findIndex(c => c.id === updated.id);
      if (activeIdx !== -1) session.activeQueue[activeIdx] = { ...session.activeQueue[activeIdx], ...updated };
      const masteredIdx = session.mastered.findIndex(c => c.id === updated.id);
      if (masteredIdx !== -1) session.mastered[masteredIdx] = { ...session.mastered[masteredIdx], ...updated };
    }

    async function populateMoveTopics(subjectId) {
      const topicSelect = el('moveCardsTopicSelect');
      const confirmBtn = el('confirmMoveCardsBtn');
      if (!topicSelect || !confirmBtn) return;
      const topics = await getTopicsBySubject(subjectId);
      topicSelect.innerHTML = '';
      topics.forEach(topic => {
        const option = document.createElement('option');
        option.value = topic.id;
        option.textContent = topic.name;
        topicSelect.appendChild(option);
      });
      topicSelect.disabled = !topics.length;
      confirmBtn.disabled = !topics.length;
    }

    async function openMoveCardsDialog() {
      const ids = getDeckSelectionIds();
      if (!ids.length) {
        alert('Bitte waehle zuerst Karten aus.');
        return;
      }
      const subjects = sortSubjectsByLastEdited(await getAll('subjects'));
      if (!subjects.length) {
        alert('Keine Subjects verfuegbar.');
        return;
      }
      const subjectSelect = el('moveCardsSubjectSelect');
      const info = el('moveCardsSelectionInfo');
      if (!subjectSelect) return;
      subjectSelect.innerHTML = '';
      subjects.forEach(subject => {
        const option = document.createElement('option');
        option.value = subject.id;
        option.textContent = subject.name;
        subjectSelect.appendChild(option);
      });
      const preferredSubjectId = subjects.some(s => s.id === selectedSubject?.id)
        ? selectedSubject.id
        : subjects[0].id;
      subjectSelect.value = preferredSubjectId;
      await populateMoveTopics(subjectSelect.value);
      if (info) {
        const cardWord = ids.length === 1 ? 'Karte' : 'Karten';
        info.textContent = `${ids.length} ${cardWord} ausgewaehlt`;
      }
      showDialog(el('moveCardsDialog'));
    }

    async function moveSelectedDeckCards() {
      const ids = getDeckSelectionIds();
      if (!ids.length) return;
      const targetTopicId = el('moveCardsTopicSelect')?.value || '';
      if (!targetTopicId) {
        alert('Bitte waehle ein Ziel-Topic aus.');
        return;
      }
      const sourceSubjectId = selectedSubject?.id || '';
      const targetSubjectId = (await getById('topics', targetTopicId))?.subjectId || '';
      const sourceTopicCards = selectedTopic?.id
        ? await getCardsByTopicIds([selectedTopic.id], { force: true })
        : await getAll('cards');
      const selectedCards = sourceTopicCards.filter(card => deckSelectedCardIds.has(card.id));
      for (const card of selectedCards) {
        if (card.topicId === targetTopicId) continue;
        const updated = { ...card, topicId: targetTopicId };
        await put('cards', updated);
        await putCardBank(updated);
        syncSessionCard(updated);
      }
      if (sourceSubjectId) await touchSubject(sourceSubjectId);
      if (targetSubjectId && targetSubjectId !== sourceSubjectId) await touchSubject(targetSubjectId);
      closeDialog(el('moveCardsDialog'));
      setDeckSelectionMode(false);
      await loadDeck();
      await loadEditorCards();
      await refreshSidebar();
      if (selectedSubject) await refreshTopicSessionMeta();
    }

    async function deleteSelectedDeckCards() {
      const ids = getDeckSelectionIds();
      if (!ids.length) return;
      const label = ids.length === 1 ? 'diese Karte' : `diese ${ids.length} Karten`;
      if (!confirm(`Moechtest du ${label} loeschen?`)) return;
      for (const cardId of ids) {
        await deleteCardById(cardId, { skipSubjectTouch: true });
      }
      if (selectedSubject?.id) await touchSubject(selectedSubject.id);
      setDeckSelectionMode(false);
      await loadDeck();
      await loadEditorCards();
      await refreshSidebar();
      if (selectedSubject) await refreshTopicSessionMeta();
    }

    function renderCardTileAnswerContent(container, card) {
      if (!container) return;
      const isMcq = card?.type === 'mcq' && Array.isArray(card?.options) && card.options.length > 1;
      if (!isMcq) {
        const answerText = String(card?.answer || '');
        const hasAnswerText = answerText.trim().length > 0;
        const hasAnswerImages = getCardImageList(card, 'A').length > 0;
        if (hasAnswerText || !hasAnswerImages) {
          renderRich(container, answerText, {
            textAlign: card?.answerTextAlign || card?.textAlign || 'center'
          });
        }
        return;
      }

      container.classList.add('card-tile-mcq');
      const optionsWrap = document.createElement('div');
      optionsWrap.className = 'card-tile-mcq-options';
      const optionsAlign = card?.optionsTextAlign || card?.answerTextAlign || card?.textAlign || 'left';
      card.options.forEach(option => {
        const row = document.createElement('div');
        row.className = 'card-tile-mcq-option';
        const textEl = document.createElement('div');
        textEl.className = 'card-tile-mcq-option-text';
        renderRich(textEl, option?.text || '', { textAlign: optionsAlign });
        row.appendChild(textEl);
        optionsWrap.appendChild(row);
      });
      container.appendChild(optionsWrap);
    }

    function buildCardTile(card, idx, compact = false) {
      const tile = document.createElement('div');
      tile.className = 'card-tile';
      if (compact) tile.classList.add('card-tile-compact');
      const selectionEnabled = deckSelectionMode && !compact;
      if (selectionEnabled) {
        tile.classList.add('selection-mode');
        tile.classList.toggle('selected-for-bulk', deckSelectedCardIds.has(card.id));
      }

      if (!selectionEnabled) {
        const menu = document.createElement('div');
        menu.className = 'card-tile-menu';
        menu.innerHTML = `
          <button class="btn card-menu-btn" type="button">‚ãØ</button>
          <div class="card-menu">
            <button class="btn card-menu-item" style="background-color: var(--success)" type="button">Edit</button>
            <button class="btn delete card-menu-item delete-card-btn" type="button">Delete</button>
          </div>
        `;
        menu.querySelector('.card-menu-item').onclick = (e) => {
          e.stopPropagation();
          openEditDialog(card);
        };
        menu.querySelector('.delete-card-btn').onclick = async (e) => {
          e.stopPropagation();
          if (!confirm('Delete this flashcard?')) return;
          await deleteCardById(card.id);
          loadDeck();
          loadEditorCards();
          refreshSidebar();
        };
        menu.querySelector('.card-menu-btn').onclick = (e) => {
          e.stopPropagation();
          menu.classList.toggle('open');
        };
        document.addEventListener('click', () => menu.classList.remove('open'));
        tile.appendChild(menu);

        if (compact) {
          const previewBtn = document.createElement('button');
          previewBtn.className = 'btn card-preview-btn';
          previewBtn.type = 'button';
          previewBtn.textContent = 'Preview';
          previewBtn.addEventListener('click', e => {
            e.stopPropagation();
            openCardPreviewDialog(card);
          });
          tile.appendChild(previewBtn);
        }
      } else {
        const selectWrap = document.createElement('label');
        selectWrap.className = 'card-select-control';
        selectWrap.innerHTML = `<input type="checkbox" aria-label="Karte auswaehlen" />`;
        const checkbox = selectWrap.querySelector('input');
        checkbox.checked = deckSelectedCardIds.has(card.id);
        checkbox.addEventListener('click', e => e.stopPropagation());
        checkbox.addEventListener('change', () => {
          toggleDeckCardSelection(card.id, checkbox.checked);
          tile.classList.toggle('selected-for-bulk', checkbox.checked);
        });
        tile.addEventListener('click', e => {
          if (e.target.closest('.card-select-control')) return;
          const nextChecked = !checkbox.checked;
          checkbox.checked = nextChecked;
          toggleDeckCardSelection(card.id, nextChecked);
          tile.classList.toggle('selected-for-bulk', nextChecked);
        });
        tile.appendChild(selectWrap);
      }

      const qTitle = document.createElement('div');
      qTitle.className = 'card-tile-title';
      qTitle.textContent = 'Q';
      const qBody = document.createElement('div');
      qBody.className = 'card-tile-body';
      renderRich(qBody, card.prompt || '', { textAlign: card.questionTextAlign || card.textAlign || 'center' });
      appendCardImages(qBody, getCardImageList(card, 'Q'), 'card-thumb', 'Question image');
      const separator = document.createElement('div');
      separator.className = 'card-tile-separator';
      const aTitle = document.createElement('div');
      aTitle.className = 'card-tile-title';
      aTitle.textContent = 'A';
      const aBody = document.createElement('div');
      aBody.className = 'card-tile-body';
      renderCardTileAnswerContent(aBody, card);
      appendCardImages(aBody, getCardImageList(card, 'A'), 'card-thumb', 'Answer image');

      tile.append(qTitle, qBody, separator, aTitle, aBody);
      return tile;
    }

    function normalizeTopicSearchQuery(value = '') {
      return String(value || '').trim().toLowerCase();
    }

    function getCardSearchHaystack(card) {
      const optionText = Array.isArray(card?.options)
        ? card.options.map(option => option?.text || '').join('\n')
        : '';
      return `${card?.prompt || ''}\n${card?.answer || ''}\n${optionText}`.toLowerCase();
    }

    function setTopicSearchMetaText(text = '') {
      const meta = el('topicSearchMeta');
      if (!meta) return;
      meta.textContent = text;
    }

    function buildTopicSearchResultCard(card, topicName = '') {
      const wrap = document.createElement('article');
      wrap.className = 'topic-search-result';

      const topicField = document.createElement('div');
      topicField.className = 'topic-search-result-topic';
      topicField.textContent = topicName || 'Unknown topic';

      const tile = document.createElement('div');
      tile.className = 'card-tile card-tile-search';

      const menu = document.createElement('div');
      menu.className = 'card-tile-menu';
      menu.innerHTML = `
        <button class="btn card-menu-btn" type="button">‚ãØ</button>
        <div class="card-menu">
          <button class="btn card-menu-item" style="background-color: var(--success)" type="button">Edit</button>
        </div>
      `;
      const editBtn = menu.querySelector('.card-menu-item');
      if (editBtn) {
        editBtn.onclick = e => {
          e.stopPropagation();
          openEditDialog(card);
          menu.classList.remove('open');
        };
      }
      const toggleBtn = menu.querySelector('.card-menu-btn');
      if (toggleBtn) {
        toggleBtn.onclick = e => {
          e.stopPropagation();
          menu.classList.toggle('open');
        };
      }
      document.addEventListener('click', () => menu.classList.remove('open'));
      tile.appendChild(menu);

      const qTitle = document.createElement('div');
      qTitle.className = 'card-tile-title';
      qTitle.textContent = 'Q';

      const qBody = document.createElement('div');
      qBody.className = 'card-tile-body';
      renderRich(qBody, card.prompt || '', { textAlign: card.questionTextAlign || card.textAlign || 'center' });
      appendCardImages(qBody, getCardImageList(card, 'Q'), 'card-thumb', 'Question image');

      const separator = document.createElement('div');
      separator.className = 'card-tile-separator';

      const aTitle = document.createElement('div');
      aTitle.className = 'card-tile-title';
      aTitle.textContent = 'A';

      const aBody = document.createElement('div');
      aBody.className = 'card-tile-body';
      renderCardTileAnswerContent(aBody, card);
      appendCardImages(aBody, getCardImageList(card, 'A'), 'card-thumb', 'Answer image');

      tile.append(qTitle, qBody, separator, aTitle, aBody);
      wrap.append(topicField, tile);
      return wrap;
    }

    async function runTopicSearch() {
      if (!selectedSubject) return;
      const input = el('topicSearchInput');
      const results = el('topicSearchResults');
      if (!input || !results) return;

      const query = normalizeTopicSearchQuery(input.value);
      const topics = await getTopicsBySubject(selectedSubject.id);
      const topicNameById = Object.fromEntries(topics.map(topic => [topic.id, topic.name]));
      const topicIds = new Set(topics.map(topic => topic.id));

      if (!query) {
        results.innerHTML = '<div class="tiny">Enter text to search cards in this subject.</div>';
        setTopicSearchMetaText(`Search in ${topics.length} ${topics.length === 1 ? 'topic' : 'topics'}.`);
        return;
      }

      const cards = await getCardsByTopicIds([...topicIds]);
      const matches = cards.filter(card => getCardSearchHaystack(card).includes(query));
      matches.sort((a, b) => getCardCreatedAt(b) - getCardCreatedAt(a));

      results.innerHTML = '';
      if (!matches.length) {
        results.innerHTML = '<div class="tiny">No matching cards found.</div>';
        setTopicSearchMetaText('0 cards found.');
        return;
      }

      matches.forEach(card => {
        results.appendChild(buildTopicSearchResultCard(card, topicNameById[card.topicId] || 'Unknown topic'));
      });
      const cardWord = matches.length === 1 ? 'card' : 'cards';
      setTopicSearchMetaText(`${matches.length} ${cardWord} found.`);
    }

    async function openTopicSearchModal() {
      if (!selectedSubject) {
        alert('Pick a subject first.');
        return;
      }
      const dialog = el('topicSearchDialog');
      const input = el('topicSearchInput');
      const results = el('topicSearchResults');
      if (!dialog || !input || !results) return;
      input.value = '';
      results.innerHTML = '';
      setTopicSearchMetaText('Enter text to search in question and answer fields.');
      showDialog(dialog);
      setTimeout(() => input.focus(), 0);
    }

    async function deleteTopicById(topicId, options = {}) {
      const { skipSubjectTouch = false } = options;
      const topic = await getById('topics', topicId);
      const subjectId = topic?.subjectId || '';
      const cards = await getCardsByTopicIds([topicId], { force: true });
      for (const c of cards) await deleteCardById(c.id, { skipSubjectTouch: true });
      await del('topics', topicId);
      if (subjectId && !skipSubjectTouch) await touchSubject(subjectId);
      selectedTopicIds.delete(topicId);
      topicSelectedIds.delete(topicId);
      if (selectedTopic?.id === topicId) selectedTopic = null;
    }

    async function deleteSubjectById(subjectId) {
      const topics = await getTopicsBySubject(subjectId, { force: true });
      for (const t of topics) await deleteTopicById(t.id, { skipSubjectTouch: true });
      await del('subjects', subjectId);
      if (selectedSubject?.id === subjectId) {
        selectedSubject = null;
        selectedTopic = null;
        setView(0);
      }
      refreshSidebar();
      loadTopics();
    }

    async function loadDeck() {
      if (!selectedTopic) {
        setDeckTopicCardCount(null);
        setDeckSelectionMode(false);
        return;
      }
      setDeckTitle(selectedTopic.name);
      const cards = await getCardsByTopicIds([selectedTopic.id]);
      setDeckTopicCardCount(cards.length);
      cards.sort((a, b) => getCardCreatedAt(b) - getCardCreatedAt(a));
      const cardIds = new Set(cards.map(card => card.id));
      deckSelectedCardIds.forEach(cardId => {
        if (!cardIds.has(cardId)) deckSelectedCardIds.delete(cardId);
      });
      const grid = el('cardsGrid');
      if (!cards.length) {
        setDeckSelectionMode(false);
        grid.innerHTML = '<div class="tiny">No cards yet.</div>';
        return;
      }
      updateDeckSelectionUi();
      grid.innerHTML = '';
      cards.forEach((c, idx) => {
        grid.appendChild(buildCardTile(c, idx));
      });
    }

    async function migrateExistingCardsToCenteredQa() {
      const cards = await getAll('cards');
      if (!cards.length) return;
      const isValidAlign = value => {
        const v = String(value || '').toLowerCase();
        return v === 'left' || v === 'center' || v === 'justify';
      };
      for (const card of cards) {
        const questionAlignRaw = card.questionTextAlign ?? card.textAlign;
        const answerAlignRaw = card.answerTextAlign ?? card.textAlign;
        const optionsAlignRaw = card.optionsTextAlign;

        const nextQuestionAlign = isValidAlign(questionAlignRaw) ? normalizeTextAlign(questionAlignRaw) : 'center';
        const nextAnswerAlign = isValidAlign(answerAlignRaw) ? normalizeTextAlign(answerAlignRaw) : 'center';
        const nextTextAlign = isValidAlign(card.textAlign) ? normalizeTextAlign(card.textAlign) : nextQuestionAlign;
        const nextOptionsAlign = isValidAlign(optionsAlignRaw) ? normalizeTextAlign(optionsAlignRaw) : 'left';

        const needsUpdate =
          card.questionTextAlign !== nextQuestionAlign ||
          card.answerTextAlign !== nextAnswerAlign ||
          card.textAlign !== nextTextAlign ||
          card.optionsTextAlign !== nextOptionsAlign;
        if (!needsUpdate) continue;
        const updated = {
          ...card,
          textAlign: nextTextAlign,
          questionTextAlign: nextQuestionAlign,
          answerTextAlign: nextAnswerAlign,
          optionsTextAlign: nextOptionsAlign
        };
        await put('cards', updated);
        await putCardBank(updated);
      }
    }

    function getCardCreatedAt(card) {
      const raw = card?.meta?.createdAt ?? card?.createdAt ?? 0;
      if (!raw) return 0;
      if (typeof raw === 'number') return raw;
      const parsed = Date.parse(raw);
      return Number.isNaN(parsed) ? 0 : parsed;
    }

    async function loadEditorCards() {
      if (!selectedTopic) return;
      const cards = await getCardsByTopicIds([selectedTopic.id]);
      cards.sort((a, b) => getCardCreatedAt(b) - getCardCreatedAt(a));
      const list = el('editorCardsList');
      if (!cards.length) {
        list.innerHTML = '<div class="tiny">No cards yet.</div>';
        return;
      }
      list.innerHTML = '';
      cards.forEach((c, idx) => {
        list.appendChild(buildCardTile(c, idx, true));
      });
    }

    async function startSession(options = {}) {
      const opts = (options && typeof options === 'object') ? options : {};
      const explicitTopicIds = Array.isArray(opts.topicIds) && opts.topicIds.length
        ? Array.from(new Set(opts.topicIds.map(topicId => String(topicId || '').trim()).filter(Boolean)))
        : [];
      const explicitCardIds = Array.isArray(opts.cardIds) && opts.cardIds.length
        ? Array.from(new Set(opts.cardIds.map(cardId => String(cardId || '').trim()).filter(Boolean)))
        : [];
      let topicIds = [...explicitTopicIds];
      if (!topicIds.length && !selectedSubject && !explicitCardIds.length) {
        return alert('Pick a subject first.');
      }
      if (!topicIds.length && selectedSubject) {
        const topics = await getTopicsBySubject(selectedSubject.id);
        topicIds = topics.map(t => t.id).filter(id => selectedTopicIds.has(id));
      }
      if (!topicIds.length && !explicitCardIds.length) {
        return alert('Select at least one topic.');
      }

      const reviewMode = opts.reviewMode === true;
      const filterConfig = normalizeSessionFilters(opts.filters || sessionFilterState);
      let cards = [];
      if (explicitCardIds.length) {
        cards = await getEligibleSessionCardsByCardIds(explicitCardIds, filterConfig, {
          payloadLabel: reviewMode ? 'daily-review-session' : 'session-cards'
        });
      } else {
        cards = await getEligibleSessionCardsByTopicIds(topicIds, filterConfig);
      }
      if (!cards.length) {
        return alert(reviewMode
          ? 'No review cards match the current selection.'
          : 'No cards match the current session filter.'
        );
      }
      if (!topicIds.length) {
        topicIds = Array.from(new Set(cards.map(card => String(card?.topicId || '').trim()).filter(Boolean)));
      }

      const maxSelectable = cards.length;
      const rawRequested = Number(opts.forcedSize ?? sessionSize);
      const requestedSize = Number.isFinite(rawRequested) ? rawRequested : sessionSize;
      sessionSize = Math.min(Math.max(requestedSize, 1), maxSelectable);
      availableSessionCards = maxSelectable;
      renderSessionSizeCounter();
      const shuffled = [...cards].sort(() => Math.random() - 0.5).slice(0, sessionSize);
      const reviewCardIdSet = new Set(explicitCardIds);
      const sessionCards = shuffled.map(card => ({
        ...card,
        sessionCorrectCount: 0,
        reviewCarryOver: reviewMode && reviewCardIdSet.has(card.id),
        reviewDowngraded: false
      }));
      session = {
        active: true,
        activeQueue: sessionCards,
        mastered: [],
        counts: Object.fromEntries(sessionCards.map(c => [c.id, 0])),
        gradeMap: {},
        mode: reviewMode ? 'daily-review' : 'default'
      };
      sessionRunState = {
        startedAt: Date.now(),
        topicIds: [...topicIds],
        cardIds: explicitCardIds.length ? [...explicitCardIds] : [],
        filters: { ...filterConfig },
        mode: reviewMode ? 'daily-review' : 'default'
      };
      closeDialog(el('sessionCompleteDialog'));
      setDeckTitle(reviewMode ? 'Daily Review' : (selectedSubject?.name || 'Study Session'));
      el('cardsOverviewSection').classList.add('hidden');
      el('studySessionSection')?.classList.remove('hidden');
      el('flashcard').classList.remove('hidden');
      setView(2);
      renderSessionPills();
      renderSessionCard();
    }

    function getSessionTextMetrics(content = '') {
      const parser = document.createElement('div');
      parser.innerHTML = markdownToHtml(content || '');
      const plainText = (parser.textContent || '').replace(/\s+/g, ' ').trim();
      const lines = String(content || '').split('\n').filter(line => line.trim().length > 0).length;
      const words = plainText ? plainText.split(' ').filter(Boolean).length : 0;
      return {
        chars: plainText.length,
        words,
        lines
      };
    }

    function computeSessionTextSizeRem(content = '', options = {}) {
      const opts = options && typeof options === 'object' ? options : {};
      const metrics = getSessionTextMetrics(content);
      const chars = metrics.chars;
      const lines = metrics.lines;
      const words = metrics.words;
      let sizeRem = 1.18;

      if (chars <= 20 && lines <= 1) sizeRem = 2.05;
      else if (chars <= 45 && lines <= 2) sizeRem = 1.82;
      else if (chars <= 80 && lines <= 3) sizeRem = 1.58;
      else if (chars <= 130 && lines <= 4) sizeRem = 1.36;
      else if (chars <= 210) sizeRem = 1.2;
      else sizeRem = 1.08;

      if (words >= 35) sizeRem -= 0.08;
      if (lines >= 6) sizeRem -= 0.1;
      if (opts.hasImage) sizeRem -= 0.2;
      if (opts.isMcq) sizeRem -= 0.08;

      const optionCount = Math.max(0, Math.trunc(Number(opts.optionCount) || 0));
      if (opts.forMcqOption && optionCount > 0) {
        if (optionCount >= 4) sizeRem -= 0.12;
        if (optionCount >= 6) sizeRem -= 0.08;
        if (chars <= 42 && lines <= 2) sizeRem += 0.08;
      }

      if (opts.preferLargerBack && !opts.hasImage && !opts.isMcq) {
        if (chars <= 170 && lines <= 5) sizeRem += 0.12;
        if (chars <= 90 && lines <= 3) sizeRem += 0.08;
      }

      const maxRem = opts.preferLargerBack ? 2.24 : 2.1;
      return Math.max(0.98, Math.min(maxRem, sizeRem));
    }

    function applySessionTextSize(container, content = '', options = {}) {
      if (!container) return;
      const sizeRem = computeSessionTextSizeRem(content, options);
      container.classList.add('session-dynamic-text');
      container.style.setProperty('--session-text-size', `${sizeRem.toFixed(3)}rem`);
    }

    function canFlipPreviewFlashcard(eventTarget = null, { allowButtonTarget = false } = {}) {
      const target = eventTarget instanceof Element ? eventTarget : null;
      if (target && target.closest('input, textarea, select, [contenteditable="true"]')) return false;
      if (!allowButtonTarget && target && target.closest('button')) return false;
      return true;
    }

    function flipPreviewFlashcard() {
      const flashcard = el('previewFlashcard');
      if (!flashcard || flashcard.classList.contains('mcq-mode')) return;
      flashcard.classList.toggle('flipped');
    }

    function applyMcqOptionsGridLayout(optionsWrap, optionCount = 0) {
      if (!optionsWrap) return;
      const total = Math.max(0, Math.trunc(Number(optionCount) || 0));
      const shouldUseTwoRows = total > 0 && total % 2 === 0;
      optionsWrap.classList.toggle('two-row-grid', shouldUseTwoRows);
      if (!shouldUseTwoRows) {
        optionsWrap.style.removeProperty('--mcq-grid-cols');
        return;
      }
      const cols = Math.max(1, total / 2);
      optionsWrap.style.setProperty('--mcq-grid-cols', String(cols));
    }

    function resolveCardTopicName(card) {
      const topicId = String(card?.topicId || '').trim();
      if (topicId) {
        const topic = topicDirectoryById.get(topicId) || null;
        const topicName = String(topic?.name || '').trim();
        if (topicName) return topicName;
        if (selectedTopic && String(selectedTopic.id || '').trim() === topicId) {
          const selectedName = String(selectedTopic.name || '').trim();
          if (selectedName) return selectedName;
        }
      }
      if (selectedTopic) {
        const selectedName = String(selectedTopic.name || '').trim();
        if (selectedName) return selectedName;
      }
      if (sessionRunState.topicIds.length === 1) {
        const fallbackTopicId = String(sessionRunState.topicIds[0] || '').trim();
        const fallbackTopic = topicDirectoryById.get(fallbackTopicId) || null;
        const fallbackName = String(fallbackTopic?.name || '').trim();
        if (fallbackName) return fallbackName;
      }
      return '';
    }

    function setCardTopicPill(pillEl, topicName = '') {
      if (!pillEl) return;
      const name = String(topicName || '').trim();
      if (!name) {
        pillEl.textContent = '';
        pillEl.removeAttribute('title');
        pillEl.classList.add('hidden');
        return;
      }
      pillEl.textContent = name;
      pillEl.title = name;
      pillEl.classList.remove('hidden');
    }

    function renderSessionTopicPills(card) {
      const topicName = resolveCardTopicName(card);
      setCardTopicPill(el('frontTopicPill'), topicName);
      setCardTopicPill(el('backTopicPill'), topicName);
    }

    function renderPreviewTopicPills(card) {
      const topicName = resolveCardTopicName(card);
      setCardTopicPill(el('previewFrontTopicPill'), topicName);
      setCardTopicPill(el('previewBackTopicPill'), topicName);
    }

    function renderCardPreviewContent(card) {
      const flashcardEl = el('previewFlashcard');
      const front = el('previewFrontContent');
      const back = el('previewBackContent');
      if (!flashcardEl || !front || !back || !card) return;
      renderPreviewTopicPills(card);

      const isMcq = card.type === 'mcq' && (card.options || []).length > 1;
      const qImages = getCardImageList(card, 'Q');
      const aImages = getCardImageList(card, 'A');
      flashcardEl.classList.remove('flipped');
      flashcardEl.dataset.type = isMcq ? 'mcq' : 'qa';
      flashcardEl.classList.toggle('mcq-mode', isMcq);

      front.innerHTML = `<div class="qtxt"></div>`;
      const qtxtEl = front.querySelector('.qtxt');
      renderRich(qtxtEl, card.prompt || '', { textAlign: card.questionTextAlign || card.textAlign || 'center' });
      applySessionTextSize(qtxtEl, card.prompt || '', { hasImage: qImages.length > 0, isMcq });
      appendSessionImages(front, qImages, 'Question image');

      if (isMcq) {
        back.innerHTML = '';
        const optionsWrap = document.createElement('div');
        optionsWrap.className = 'mcq-options';
        const optionCount = (card.options || []).length;
        const optionsAlign = card.optionsTextAlign || card.answerTextAlign || card.textAlign || 'left';
        (card.options || []).forEach(option => {
          const optionEl = document.createElement('button');
          optionEl.type = 'button';
          optionEl.className = 'mcq-option';
          optionEl.disabled = true;
          optionEl.tabIndex = -1;
          const textEl = document.createElement('span');
          textEl.className = 'mcq-text';
          renderRich(textEl, option?.text || '', { textAlign: optionsAlign });
          applySessionTextSize(textEl, option?.text || '', {
            forMcqOption: true,
            optionCount
          });
          optionEl.appendChild(textEl);
          optionsWrap.appendChild(optionEl);
        });
        applyMcqOptionsGridLayout(optionsWrap, optionCount);
        const separator = document.createElement('div');
        separator.className = 'card-tile-separator';
        const checkRow = document.createElement('div');
        checkRow.className = 'mcq-check-row';
        const checkBtn = document.createElement('button');
        checkBtn.className = 'btn mcq-check-btn';
        checkBtn.type = 'button';
        checkBtn.textContent = 'Check';
        checkBtn.disabled = true;
        checkRow.appendChild(checkBtn);
        front.append(separator, optionsWrap, checkRow);
      } else {
        back.innerHTML = `<div class="atxt"></div>`;
        const atxtEl = back.querySelector('.atxt');
        renderRich(atxtEl, card.answer || '', { textAlign: card.answerTextAlign || card.textAlign || 'center' });
        applySessionTextSize(atxtEl, card.answer || '', {
          hasImage: aImages.length > 0,
          preferLargerBack: true
        });
      }
      appendSessionImages(back, aImages, 'Answer image');
    }

    function openCardPreviewDialog(card) {
      if (!card) return;
      const dialog = el('cardPreviewDialog');
      if (!dialog) return;
      renderCardPreviewContent(card);
      showDialog(dialog);
    }

    function renderCardContent(card) {
      const isMcq = card.type === 'mcq' && (card.options || []).length > 1;
      const front = el('frontContent');
      const back = el('backContent');
      const qImages = getCardImageList(card, 'Q');
      const aImages = getCardImageList(card, 'A');
      renderSessionTopicPills(card);
      const flashcardEl = el('flashcard');
      if (flashcardEl) {
        flashcardEl.dataset.type = isMcq ? 'mcq' : 'qa';
        flashcardEl.classList.toggle('mcq-mode', isMcq);
      }
      const sessionSection = el('studySessionSection');
      if (sessionSection) sessionSection.classList.toggle('mcq-mode', isMcq);

      let promptHtml = `<div></div><div class="qtxt"></div>`;
      front.innerHTML = promptHtml;
      const qtxtEl = front.querySelector('.qtxt');
      renderRich(qtxtEl, card.prompt, { textAlign: card.questionTextAlign || card.textAlign || 'center' });
      applySessionTextSize(qtxtEl, card.prompt, { hasImage: qImages.length > 0, isMcq });
      appendSessionImages(front, qImages, 'Question image');
      if (isMcq) {
        const opts = card.options || [];
        const optionCount = opts.length;
        const optionsWrap = document.createElement('div');
        optionsWrap.className = 'mcq-options';
        opts.forEach((o, i) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'mcq-option';
          btn.dataset.idx = String(i);
          const textEl = document.createElement('span');
          textEl.className = 'mcq-text';
          renderRich(textEl, o.text || '', {
            textAlign: card.optionsTextAlign || 'left'
          });
          applySessionTextSize(textEl, o.text || '', {
            forMcqOption: true,
            optionCount
          });
          btn.appendChild(textEl);
          btn.addEventListener('click', () => {
            btn.classList.toggle('selected');
          });
          optionsWrap.appendChild(btn);
        });
        applyMcqOptionsGridLayout(optionsWrap, optionCount);
        const checkRow = document.createElement('div');
        checkRow.className = 'mcq-check-row';
        const checkBtn = document.createElement('button');
        checkBtn.className = 'btn mcq-check-btn';
        checkBtn.textContent = 'Check';
        checkRow.appendChild(checkBtn);
        const separator = document.createElement('div');
        separator.className = 'card-tile-separator';
        front.appendChild(separator);
        front.appendChild(optionsWrap);
        front.appendChild(checkRow);

        checkBtn.onclick = async e => {
          e.stopPropagation();
          const buttons = Array.from(optionsWrap.querySelectorAll('.mcq-option'));
          const selected = buttons
            .filter(b => b.classList.contains('selected'))
            .map(b => Number(b.dataset.idx));
          const correctIdx = opts.map((o, i) => o.correct ? i : null).filter(i => i !== null);
          const correctSet = new Set(correctIdx);
          const selectedSet = new Set(selected);
          const selectedCorrect = selected.filter(i => correctSet.has(i)).length;
          const selectedWrong = selected.filter(i => !correctSet.has(i)).length;
          const correctCount = correctIdx.length || 0;

          // visual feedback
          buttons.forEach((btn, i) => {
            btn.classList.remove('correct', 'wrong');
            if (correctSet.has(i)) btn.classList.add('correct');
            if (btn.classList.contains('selected') && !correctSet.has(i)) btn.classList.add('wrong');
          });

          let result = 'wrong';
          if (selectedWrong > 0) {
            result = 'wrong';
          } else if (selectedCorrect === correctCount && correctCount > 0) {
            result = 'correct';
          } else if (correctCount > 1 && selectedCorrect / correctCount >= 0.5) {
            result = 'partial';
          } else {
            result = 'wrong';
          }

          checkBtn.textContent = 'Next';
          checkBtn.onclick = ev => {
            ev.stopPropagation();
            checkBtn.textContent = 'Check';
            // reset option visuals for next card
            buttons.forEach(btn => btn.classList.remove('correct', 'wrong', 'selected'));
            gradeCard(result);
          };
        };
      } else {
        back.innerHTML = `<div></div><div class="atxt"></div>`;
        const atxtEl = back.querySelector('.atxt');
        renderRich(atxtEl, card.answer || '', { textAlign: card.answerTextAlign || card.textAlign || 'center' });
        applySessionTextSize(atxtEl, card.answer || '', {
          hasImage: aImages.length > 0,
          preferLargerBack: true
        });
      }
      appendSessionImages(back, aImages, 'Answer image');
    }

    async function renderSessionCard() {
      if (!session.active) return;
      const flashcard = el('flashcard');
      if (!flashcard) return;
      closeStudyImageLightbox();
      flashcard.classList.remove('flipped', 'swiping', 'swipe-correct', 'swipe-wrong', 'swipe-partial');
      flashcard.style.removeProperty('--swipe-intensity');
      flashcard.style.transform = '';
      flashcard.style.transition = '';
      flashcard.style.willChange = '';
      const swipeBadge = el('swipeBadge');
      if (swipeBadge) swipeBadge.textContent = '';
      if (!session.activeQueue.length) {
        session.active = false;
        el('cardsOverviewSection').classList.remove('hidden');
        el('studySessionSection')?.classList.add('hidden');
        syncSidebarHiddenState();
        renderSessionPills();
        if (selectedSubject) await refreshTopicSessionMeta();
        await openSessionCompleteDialog();
        return;
      }
      const card = session.activeQueue[0];
      flashcard.classList.remove('flipped');
      renderCardContent(card);
    }

    function getSessionCardMasteryTarget(card) {
      if (session.mode === 'daily-review' && card?.reviewCarryOver === true && card?.reviewDowngraded !== true) {
        return 1;
      }
      return 3;
    }

    async function gradeCard(result) {
      if (!session.active) return;
      const card = session.activeQueue.shift();
      if (!card) return;
      let count = session.counts[card.id] ?? 0;

      if (result === 'correct') count += 1;
      else count = 0;

      if (result !== 'correct' && session.mode === 'daily-review' && card.reviewCarryOver === true) {
        card.reviewCarryOver = false;
        card.reviewDowngraded = true;
      }
      const masteryTarget = getSessionCardMasteryTarget(card);

      session.counts[card.id] = count;
      card.sessionCorrectCount = count;
      await recordCardProgress(card.id, result, { masteryTarget });

      if (result === 'correct' && count >= masteryTarget) {
        session.mastered.push(card);
        delete session.gradeMap[card.id];
      } else if (result === 'wrong') {
        const target = Math.min(4, session.activeQueue.length);
        session.activeQueue.splice(target, 0, card);
        session.gradeMap[card.id] = result;
      } else {
        session.activeQueue.push(card);
        session.gradeMap[card.id] = result;
      }

      renderSessionPills();
      await renderSessionCard();
      loadDeck();
    }

    function renderSessionPills() {
      const masteredWrap = el('masteredPills');
      const activeWrap = el('activePills');
      if (!masteredWrap || !activeWrap) return;
      if (!session.active) {
        masteredWrap.innerHTML = '';
        activeWrap.innerHTML = '';
        return;
      }

      const prev = new Map();
      document.querySelectorAll('.pill-dot').forEach(el => {
        prev.set(el.dataset.id, el.getBoundingClientRect());
      });

      masteredWrap.innerHTML = '';
      activeWrap.innerHTML = '';

      session.mastered.forEach(card => {
        const dot = document.createElement('div');
        dot.className = 'pill-dot mastered';
        dot.dataset.id = card.id;
        masteredWrap.appendChild(dot);
      });

      session.activeQueue.forEach((card, idx) => {
        const dot = document.createElement('div');
        dot.className = 'pill-dot';
        dot.dataset.id = card.id;
        if (idx === 0) dot.classList.add('current');
        if (card.reviewCarryOver) dot.classList.add('review-ready');
        const correctCount = session.counts[card.id] ?? card.sessionCorrectCount ?? 0;
        if (correctCount >= 2) dot.classList.add('near-master');
        const grade = session.gradeMap[card.id];
        if (grade) dot.classList.add(grade);
        activeWrap.appendChild(dot);
      });

      requestAnimationFrame(() => {
        document.querySelectorAll('.pill-dot').forEach(el => {
          const prevRect = prev.get(el.dataset.id);
          if (!prevRect) return;
          const nextRect = el.getBoundingClientRect();
          const dx = prevRect.left - nextRect.left;
          const dy = prevRect.top - nextRect.top;
          if (dx || dy) {
            el.style.transform = `translate(${dx}px, ${dy}px)`;
            el.style.transition = 'transform 0s';
            requestAnimationFrame(() => {
              el.style.transform = '';
              el.style.transition = 'transform 0.3s ease';
            });
          }
        });
      });
    }

    function wireSwipe() {
      const card = el('flashcard');
      if (!card) return;
      const rotateLimit = 15;
      let dragging = false;
      let startX = 0;
      let startY = 0;
      let dx = 0;
      let dy = 0;

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function swipeBaseTransform() {
        return card.classList.contains('flipped') ? ' rotateX(180deg)' : '';
      }

      function setSwipeTransform(x = 0, y = 0, rotate = 0) {
        card.style.transform = `translate3d(${x}px, ${y}px, 0) rotate(${rotate}deg)${swipeBaseTransform()}`;
      }

      function clearSwipeFeedback() {
        card.classList.remove('swiping', 'swipe-correct', 'swipe-wrong', 'swipe-partial');
        card.style.removeProperty('--swipe-intensity');
        const badge = el('swipeBadge');
        if (badge) badge.textContent = '';
      }

      function applySwipeFeedback(result, intensity) {
        clearSwipeFeedback();
        if (!result || intensity <= 0) return;
        const labels = {
          correct: 'Korrekt',
          wrong: 'Falsch',
          partial: 'Teilweise'
        };
        const cls = {
          correct: 'swipe-correct',
          wrong: 'swipe-wrong',
          partial: 'swipe-partial'
        }[result];
        card.classList.add('swiping', cls);
        card.style.setProperty('--swipe-intensity', String(clamp(intensity, 0, 1)));
        const badge = el('swipeBadge');
        if (badge) badge.textContent = labels[result] || '';
      }

      function getSwipeResult() {
        const xThreshold = Math.max(card.clientWidth * 0.25, 60);
        const yThreshold = Math.max(card.clientHeight * 0.25, 80);
        if (Math.abs(dx) >= Math.abs(dy) && Math.abs(dx) > xThreshold) {
          return dx < 0 ? 'correct' : 'wrong';
        }
        if (dy > yThreshold) return 'partial';
        return null;
      }

      function snapBack() {
        card.style.transition = 'transform 380ms cubic-bezier(0.18, 0.89, 0.32, 1.28)';
        applySwipeFeedback(null, 0);
        requestAnimationFrame(() => setSwipeTransform(0, 0, 0));
        setTimeout(() => {
          card.style.transition = '';
          card.style.willChange = '';
          card.style.transform = '';
          clearSwipeFeedback();
        }, 390);
      }

      function flyOut(result) {
        const width = Math.max(card.clientWidth, 1);
        let outX = dx;
        let outY = dy;
        let outRotate = clamp((dx / width) * rotateLimit, -rotateLimit, rotateLimit);

        if (result === 'correct') {
          outX = -window.innerWidth * 1.15;
          outY = dy * 0.15;
          outRotate = -rotateLimit;
        } else if (result === 'wrong') {
          outX = window.innerWidth * 1.15;
          outY = dy * 0.15;
          outRotate = rotateLimit;
        } else {
          outX = dx * 0.2;
          outY = window.innerHeight * 1.1;
          outRotate = clamp((dx / width) * 8, -8, 8);
        }

        card.style.transition = 'transform 240ms cubic-bezier(0.2, 0.8, 0.2, 1)';
        applySwipeFeedback(result, 1);
        requestAnimationFrame(() => setSwipeTransform(outX, outY, outRotate));
        setTimeout(() => {
          gradeCard(result);
        }, 210);
      }

      card.addEventListener('touchstart', e => {
        if (card.dataset.type === 'mcq' || !session.active) return;
        if (!e.touches[0]) return;
        dragging = true;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        dx = 0;
        dy = 0;
        card.style.transition = 'none';
        card.style.willChange = 'transform';
        clearSwipeFeedback();
      }, { passive: true });

      card.addEventListener('touchmove', e => {
        if (!dragging || card.dataset.type === 'mcq') return;
        if (!e.touches[0]) return;
        dx = e.touches[0].clientX - startX;
        dy = e.touches[0].clientY - startY;
        if (Math.abs(dx) + Math.abs(dy) > 4) e.preventDefault();

        const width = Math.max(card.clientWidth, 1);
        const xThreshold = Math.max(width * 0.25, 60);
        const yThreshold = Math.max(card.clientHeight * 0.25, 80);
        const rotate = clamp((dx / width) * rotateLimit, -rotateLimit, rotateLimit);
        setSwipeTransform(dx, dy, rotate);

        let result = null;
        let intensity = 0;
        if (Math.abs(dx) >= Math.abs(dy)) {
          result = dx <= 0 ? 'correct' : 'wrong';
          intensity = Math.min(Math.abs(dx) / xThreshold, 1);
        } else if (dy > 0) {
          result = 'partial';
          intensity = Math.min(dy / yThreshold, 1);
        }
        applySwipeFeedback(result, intensity);
      }, { passive: false });

      const finishSwipe = () => {
        if (!dragging) return;
        dragging = false;
        if (Math.abs(dx) > 8 || Math.abs(dy) > 8) {
          suppressFlashcardTapUntil = Date.now() + 260;
        }
        const result = getSwipeResult();
        if (result) {
          flyOut(result);
          return;
        }
        snapBack();
      };

      card.addEventListener('touchend', finishSwipe);
      card.addEventListener('touchcancel', finishSwipe);
    }

    function isStudySessionVisible() {
      const section = el('studySessionSection');
      return currentView === 2 && section && !section.classList.contains('hidden');
    }

    function isCoarsePointerDevice() {
      return window.matchMedia('(pointer: coarse)').matches || navigator.maxTouchPoints > 0;
    }

    function canOpenSidebarBySwipe(target = null) {
      if (!isCoarsePointerDevice()) return false;
      if (document.body.classList.contains('sidebar-open')) return false;
      if (isStudySessionVisible()) return false;
      const element = target instanceof Element ? target : target?.parentElement;
      if (element && element.closest('input, textarea, select, [contenteditable="true"], dialog[open], .flashcard')) {
        return false;
      }
      return true;
    }

    function wireSidebarSwipeGesture() {
      const edgeZone = 200;
      const openThreshold = 68;
      const verticalCancelThreshold = 28;
      let tracking = false;
      let startX = 0;
      let startY = 0;

      const resetTracking = () => {
        tracking = false;
        startX = 0;
        startY = 0;
      };

      document.addEventListener('touchstart', e => {
        if (e.touches.length !== 1) return;
        const touch = e.touches[0];
        if (!touch || touch.clientX > edgeZone) return;
        if (!canOpenSidebarBySwipe(e.target)) return;
        tracking = true;
        startX = touch.clientX;
        startY = touch.clientY;
      }, { passive: true });

      document.addEventListener('touchmove', e => {
        if (!tracking) return;
        const touch = e.touches[0];
        if (!touch) {
          resetTracking();
          return;
        }
        const dx = touch.clientX - startX;
        const dy = touch.clientY - startY;

        if (Math.abs(dy) > verticalCancelThreshold && Math.abs(dy) > Math.abs(dx)) {
          resetTracking();
          return;
        }
        if (dx > 0 && Math.abs(dx) > Math.abs(dy)) e.preventDefault();
      }, { passive: false });

      document.addEventListener('touchend', e => {
        if (!tracking) return;
        const touch = e.changedTouches?.[0];
        const dx = touch ? touch.clientX - startX : 0;
        const dy = touch ? touch.clientY - startY : 0;
        const horizontalSwipe = dx > 0 && Math.abs(dx) > Math.abs(dy);
        if (horizontalSwipe && dx >= openThreshold && canOpenSidebarBySwipe()) {
          document.body.classList.add('sidebar-open');
          triggerHaptic('light');
        }
        resetTracking();
      }, { passive: true });

      document.addEventListener('touchcancel', resetTracking, { passive: true });
    }

    function openSubjectDialog() {
      el('subjectNameInput').value = '';
      el('subjectAccentPicker').value = '#2dd4bf';
      el('subjectAccentText').value = '#2dd4bf';
      showDialog(el('subjectDialog'));
    }

    async function addSubjectFromDialog() {
      const name = el('subjectNameInput').value.trim();
      if (!name) return;
      const accent = el('subjectAccentText').value.trim() || '#2dd4bf';
      const subject = buildSubjectRecord({ id: uid(), name, accent });
      await put('subjects', subject);
      closeDialog(el('subjectDialog'));
      refreshSidebar();
    }

    async function exportJSON() {
      const subjects = await getAll('subjects');
      const topics = await getAll('topics');
      const cards = await getAll('cards');
      const subjectMap = Object.fromEntries(subjects.map(s => [s.id, s]));
      const topicMap = Object.fromEntries(topics.map(t => [t.id, t]));
      const payload = {
        subjects,
        topics: topics.map(t => ({
          ...t,
          subjectName: subjectMap[t.subjectId]?.name || ''
        })),
        cards: cards.map(c => ({
          ...c,
          topicName: topicMap[c.topicId]?.name || '',
          subjectName: subjectMap[topicMap[c.topicId]?.subjectId]?.name || ''
        })),
        progress: await getAll('progress')
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'flashcards-export.json';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    async function exportCSV() {
      const subjects = await getAll('subjects');
      const topics = await getAll('topics');
      const cards = await getAll('cards');
      const subjectMap = Object.fromEntries(subjects.map(s => [s.id, s]));
      const topicMap = Object.fromEntries(topics.map(t => [t.id, t]));
      const lines = ['id,topicId,topicName,subjectName,type,prompt,answer,options'];
      cards.forEach(c => {
        const options = c.options ? JSON.stringify(c.options).replaceAll('"', '""') : '';
        const esc = s => `"${String(s || '').replaceAll('"', '""')}"`;
        const topic = topicMap[c.topicId];
        const subject = topic ? subjectMap[topic.subjectId] : null;
        lines.push([
          c.id,
          c.topicId,
          esc(topic?.name || ''),
          esc(subject?.name || ''),
          c.type,
          esc(c.prompt),
          esc(c.answer),
          esc(options)
        ].join(','));
      });
      const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'flashcards-cards.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    async function importJSON(file) {
      const text = await file.text();
      const data = JSON.parse(text);
      for (const s of ['subjects', 'topics', 'cards', 'progress']) {
        for (const row of (data[s] || [])) {
          await put(s, row);
          if (s === 'cards') await putCardBank(row);
        }
      }
      progressByCardId = new Map();
      alert('Imported successfully.');
      refreshSidebar();
      if (selectedSubject) loadTopics();
      if (selectedTopic) loadDeck();
    }

    async function boot() {
      try {
        await openDB();
        await openCardBankDB();
        await preloadTopicDirectory({ force: true });
      } catch (err) {
        alert(err.message || 'Unable to connect to the local server.');
        return;
      }
      wireNoZoomGuards();
      wireSwipe();
      wireHapticFeedback();
      wireSidebarSwipeGesture();

      el('homeBtn').onclick = () => {
        setView(0);
        document.body.classList.remove('sidebar-open');
        void refreshDailyReviewHomePanel({ useExisting: false });
      };
      el('settingsBtn').onclick = () => document.getElementById('settingsDialog').showModal();
      const quickAddSubjectBtn = el('quickAddSubject');
      if (quickAddSubjectBtn) quickAddSubjectBtn.onclick = openSubjectDialog;
      el('addSubjectBtn').onclick = openSubjectDialog;
      const quickExportBtn = el('quickExport');
      if (quickExportBtn) quickExportBtn.onclick = exportJSON;
      const openProgressCheckBtn = el('openProgressCheckBtn');
      if (openProgressCheckBtn) openProgressCheckBtn.onclick = openProgressCheckDialog;
      const openProgressCheckFromSettingsBtn = el('openProgressCheckFromSettingsBtn');
      if (openProgressCheckFromSettingsBtn) {
        openProgressCheckFromSettingsBtn.onclick = async () => {
          const settingsDialog = el('settingsDialog');
          if (settingsDialog?.open) closeDialog(settingsDialog);
          await openProgressCheckDialog();
        };
      }
      const startBtn = el('startSessionBtn');
      if (startBtn) startBtn.onclick = startSession;
      const openSessionFilterBtn = el('openSessionFilterBtn');
      if (openSessionFilterBtn) {
        openSessionFilterBtn.onclick = () => {
          fillSessionFilterDialogFromState();
          showDialog(el('sessionFilterDialog'));
        };
      }

      const sessionFilterDialog = el('sessionFilterDialog');
      if (sessionFilterDialog) {
        sessionFilterDialog.addEventListener('click', e => {
          if (e.target === sessionFilterDialog) closeDialog(sessionFilterDialog);
        });
      }
      const sessionFilterAll = el('sessionFilterAll');
      const sessionFilterCorrect = el('sessionFilterCorrect');
      const sessionFilterWrong = el('sessionFilterWrong');
      const sessionFilterPartial = el('sessionFilterPartial');
      const sessionFilterNotAnswered = el('sessionFilterNotAnswered');
      if (sessionFilterAll) {
        sessionFilterAll.addEventListener('change', () => {
          if (sessionFilterAll.checked) {
            if (sessionFilterCorrect) sessionFilterCorrect.checked = false;
            if (sessionFilterWrong) sessionFilterWrong.checked = false;
            if (sessionFilterPartial) sessionFilterPartial.checked = false;
            if (sessionFilterNotAnswered) sessionFilterNotAnswered.checked = false;
          }
          syncSessionFilterDialogControls();
        });
      }
      [sessionFilterCorrect, sessionFilterWrong, sessionFilterPartial, sessionFilterNotAnswered].forEach(input => {
        if (!input) return;
        input.addEventListener('change', () => {
          if (input.checked && sessionFilterAll) sessionFilterAll.checked = false;
          syncSessionFilterDialogControls();
        });
      });
      const cancelSessionFilterBtn = el('cancelSessionFilterBtn');
      if (cancelSessionFilterBtn) {
        cancelSessionFilterBtn.onclick = () => closeDialog(el('sessionFilterDialog'));
      }
      const saveSessionFilterBtn = el('saveSessionFilterBtn');
      if (saveSessionFilterBtn) {
        saveSessionFilterBtn.onclick = async () => {
          const next = pullSessionFiltersFromDialog();
          await setSessionFilterState(next, { refresh: true });
          closeDialog(el('sessionFilterDialog'));
        };
      }

      const sessionCompleteDialog = el('sessionCompleteDialog');
      if (sessionCompleteDialog) {
        sessionCompleteDialog.addEventListener('click', e => {
          if (e.target === sessionCompleteDialog) closeDialog(sessionCompleteDialog);
        });
      }
      const closeSessionCompleteBtn = el('closeSessionCompleteBtn');
      if (closeSessionCompleteBtn) {
        closeSessionCompleteBtn.onclick = () => closeDialog(el('sessionCompleteDialog'));
      }
      const sessionRepeatMinus = el('sessionRepeatMinus');
      if (sessionRepeatMinus) {
        sessionRepeatMinus.onclick = () => {
          if (sessionRepeatState.remaining <= 0) return;
          sessionRepeatState.size = Math.max(1, sessionRepeatState.size - 1);
          updateSessionRepeatCounter();
        };
      }
      const sessionRepeatPlus = el('sessionRepeatPlus');
      if (sessionRepeatPlus) {
        sessionRepeatPlus.onclick = () => {
          if (sessionRepeatState.remaining <= 0) return;
          sessionRepeatState.size = Math.min(sessionRepeatState.remaining, sessionRepeatState.size + 1);
          updateSessionRepeatCounter();
        };
      }
      const startAnotherSessionBtn = el('startAnotherSessionBtn');
      if (startAnotherSessionBtn) {
        startAnotherSessionBtn.onclick = async () => {
          if (sessionRepeatState.remaining <= 0) {
            closeDialog(el('sessionCompleteDialog'));
            return;
          }
          const forcedSize = Math.min(Math.max(sessionRepeatState.size, 1), sessionRepeatState.remaining);
          closeDialog(el('sessionCompleteDialog'));
          await startSession({
            topicIds: [...sessionRepeatState.topicIds],
            cardIds: [...sessionRepeatState.cardIds],
            filters: { ...sessionRepeatState.filters },
            forcedSize,
            reviewMode: sessionRepeatState.mode === 'daily-review'
          });
        };
      }

      const startDailyReviewBtn = el('startDailyReviewBtn');
      if (startDailyReviewBtn) startDailyReviewBtn.onclick = startDailyReviewFromHomePanel;
      const dailyReviewFilterIds = ['dailyReviewFilterGreen', 'dailyReviewFilterYellow', 'dailyReviewFilterRed'];
      dailyReviewFilterIds.forEach(filterId => {
        const input = el(filterId);
        if (!input) return;
        input.addEventListener('change', () => {
          dailyReviewState.statusFilter = pullDailyReviewStatusFilterFromControls();
          renderDailyReviewFilterSummary();
          renderDailyReviewTopicList();
        });
      });
      const dailyReviewMinus = el('dailyReviewMinus');
      if (dailyReviewMinus) {
        dailyReviewMinus.onclick = () => {
          const selectedCount = getDailyReviewSelectedCardIds().length;
          if (selectedCount <= 0) return;
          dailyReviewState.size = Math.max(1, dailyReviewState.size - 1);
          updateDailyReviewSizeCounter();
        };
      }
      const dailyReviewPlus = el('dailyReviewPlus');
      if (dailyReviewPlus) {
        dailyReviewPlus.onclick = () => {
          const selectedCount = getDailyReviewSelectedCardIds().length;
          if (selectedCount <= 0) return;
          dailyReviewState.size = Math.min(selectedCount, dailyReviewState.size + 1);
          updateDailyReviewSizeCounter();
        };
      }
      renderSessionFilterSummary();

      el('backToTopicsBtn').onclick = async () => {
        setDeckSelectionMode(false);

        await preloadTopicDirectory({ force: true });
        await loadTopics();

        console.log('Back to topics loaded (counts refreshed)');

        if (selectedSubject) refreshTopicSessionMeta();
        setView(1);
      };
      el('backToTopicsBtnSession').onclick = () => {
        closeStudyImageLightbox();
        setDeckSelectionMode(false);
        session.active = false;
        el('cardsOverviewSection').classList.remove('hidden');
        el('studySessionSection')?.classList.add('hidden');
        renderSessionPills();
        if (selectedSubject) refreshTopicSessionMeta();
        const returnToHome = session.mode === 'daily-review';
        setView(returnToHome ? 0 : 1);
        if (returnToHome) void refreshDailyReviewHomePanel({ useExisting: false });
      };
      el('backToDeckBtn').onclick = () => setView(2);
      const flashcardEl = el('flashcard');
      if (flashcardEl) {
        const canFlipSessionFlashcard = (eventTarget = null, opts = {}) => {
          const options = opts && typeof opts === 'object' ? opts : {};
          const allowButtonTarget = !!options.allowButtonTarget;
          if (!session.active || !isStudySessionVisible()) return false;
          if (document.body.classList.contains('session-image-open')) return false;
          if (document.querySelector('dialog[open]')) return false;
          if (Date.now() < suppressFlashcardTapUntil) return false;
          if (flashcardEl.classList.contains('swiping')) return false;
          if (flashcardEl.dataset.type === 'mcq') return false;
          if (hasActiveTextSelection()) return false;
          const target = eventTarget instanceof Element ? eventTarget : null;
          if (target && target.closest('.card-edit-btn, input, textarea, select, [contenteditable="true"]')) {
            return false;
          }
          if (!allowButtonTarget && target && target.closest('button')) return false;
          return true;
        };
        const flipSessionFlashcard = () => {
          flashcardEl.classList.toggle('flipped');
        };

        flashcardEl.onclick = e => {
          if (!canFlipSessionFlashcard(e.target)) return;
          flipSessionFlashcard();
        };

        document.addEventListener('keydown', e => {
          if (e.key === 'Escape') closeStudyImageLightbox();
          const target = e.target instanceof Element ? e.target : null;
          const editingTarget = target && target.closest('input, textarea, select, [contenteditable="true"]');
          const gradeByCode = {
            Digit1: 'correct',
            Numpad1: 'correct',
            Digit2: 'partial',
            Numpad2: 'partial',
            Digit3: 'wrong',
            Numpad3: 'wrong'
          };
          const gradeFromCode = gradeByCode[e.code] || null;
          const gradeFromKey = e.key === '1' ? 'correct' : e.key === '2' ? 'partial' : e.key === '3' ? 'wrong' : null;
          const gradeResult = gradeFromCode || gradeFromKey;
          if (
            gradeResult &&
            !e.repeat &&
            !e.metaKey &&
            !e.ctrlKey &&
            !e.altKey &&
            !e.shiftKey &&
            !editingTarget &&
            !hasActiveTextSelection() &&
            session.active &&
            isStudySessionVisible() &&
            !document.body.classList.contains('session-image-open') &&
            !document.querySelector('dialog[open]')
          ) {
            e.preventDefault();
            gradeCard(gradeResult);
            return;
          }
          const isSpace = e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar';
          if (!isSpace || e.repeat) return;
          if (!canFlipSessionFlashcard(e.target, { allowButtonTarget: true })) return;
          e.preventDefault();
          flipSessionFlashcard();
        });
        document.addEventListener('keyup', e => {
          const isSpace = e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar';
          if (!isSpace) return;
          if (!canFlipSessionFlashcard(e.target, { allowButtonTarget: true })) return;
          e.preventDefault();
        });
      }
      const editBtn = el('editSessionCardBtn');
      if (editBtn) {
        editBtn.onclick = () => {
          if (!session.active) return;
          const card = session.activeQueue[0];
          if (!card) return;
          openEditDialog(card);
        };
      }
      const editBtnBack = el('editSessionCardBtnBack');
      if (editBtnBack && editBtn) editBtnBack.onclick = () => editBtn.click();
      const editDialog = el('editCardDialog');
      if (editDialog) {
        editDialog.addEventListener('click', e => {
          if (e.target === editDialog) editDialog.close();
        });
      }
      const cardPreviewDialog = el('cardPreviewDialog');
      const closeCardPreviewBtn = el('closeCardPreviewBtn');
      const previewFlashcardEl = el('previewFlashcard');
      if (closeCardPreviewBtn && cardPreviewDialog) {
        closeCardPreviewBtn.onclick = () => closeDialog(cardPreviewDialog);
      }
      if (cardPreviewDialog) {
        cardPreviewDialog.addEventListener('click', e => {
          if (e.target === cardPreviewDialog) closeDialog(cardPreviewDialog);
        });
        cardPreviewDialog.addEventListener('keydown', e => {
          if (e.key === 'Escape') {
            e.preventDefault();
            closeDialog(cardPreviewDialog);
            return;
          }
          const isSpace = e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar';
          if (!isSpace || e.repeat) return;
          if (!canFlipPreviewFlashcard(e.target, { allowButtonTarget: true })) return;
          e.preventDefault();
          flipPreviewFlashcard();
        });
      }
      if (previewFlashcardEl) {
        previewFlashcardEl.addEventListener('click', e => {
          if (!canFlipPreviewFlashcard(e.target)) return;
          flipPreviewFlashcard();
        });
      }

      const sessionImageLightbox = el('sessionImageLightbox');
      const sessionImageLightboxImg = el('sessionImageLightboxImg');
      if (sessionImageLightbox) {
        sessionImageLightbox.addEventListener('click', () => closeStudyImageLightbox());
      }
      if (sessionImageLightboxImg) {
        sessionImageLightboxImg.addEventListener('click', e => {
          e.stopPropagation();
          closeStudyImageLightbox();
        });
      }

      const moveCardsDialog = el('moveCardsDialog');
      if (moveCardsDialog) {
        moveCardsDialog.addEventListener('click', e => {
          if (e.target === moveCardsDialog) closeDialog(moveCardsDialog);
        });
      }

      const toggleCardSelectBtn = el('toggleCardSelectBtn');
      if (toggleCardSelectBtn) {
        toggleCardSelectBtn.onclick = () => {
          setDeckSelectionMode(!deckSelectionMode);
          loadDeck();
        };
      }
      const cancelCardSelectionBtn = el('cancelCardSelectionBtn');
      if (cancelCardSelectionBtn) {
        cancelCardSelectionBtn.onclick = () => {
          setDeckSelectionMode(false);
          loadDeck();
        };
      }
      const deleteSelectedCardsBtn = el('deleteSelectedCardsBtn');
      if (deleteSelectedCardsBtn) deleteSelectedCardsBtn.onclick = deleteSelectedDeckCards;
      const moveSelectedCardsBtn = el('moveSelectedCardsBtn');
      if (moveSelectedCardsBtn) moveSelectedCardsBtn.onclick = openMoveCardsDialog;

      const moveCardsSubjectSelect = el('moveCardsSubjectSelect');
      if (moveCardsSubjectSelect) {
        moveCardsSubjectSelect.addEventListener('change', () => populateMoveTopics(moveCardsSubjectSelect.value));
      }
      const confirmMoveCardsBtn = el('confirmMoveCardsBtn');
      if (confirmMoveCardsBtn) confirmMoveCardsBtn.onclick = moveSelectedDeckCards;
      const cancelMoveCardsBtn = el('cancelMoveCardsBtn');
      if (cancelMoveCardsBtn) cancelMoveCardsBtn.onclick = () => closeDialog(el('moveCardsDialog'));
      updateDeckSelectionUi();

      const moveTopicsDialog = el('moveTopicsDialog');
      if (moveTopicsDialog) {
        moveTopicsDialog.addEventListener('click', e => {
          if (e.target === moveTopicsDialog) closeDialog(moveTopicsDialog);
        });
      }
      const progressCheckDialog = el('progressCheckDialog');
      if (progressCheckDialog) {
        progressCheckDialog.addEventListener('click', e => {
          if (e.target === progressCheckDialog) closeDialog(progressCheckDialog);
        });
      }
      const closeProgressCheckBtn = el('closeProgressCheckBtn');
      if (closeProgressCheckBtn) closeProgressCheckBtn.onclick = () => closeDialog(el('progressCheckDialog'));
      const refreshProgressCheckBtn = el('refreshProgressCheckBtn');
      if (refreshProgressCheckBtn) refreshProgressCheckBtn.onclick = renderProgressCheckTable;
      const topicSearchDialog = el('topicSearchDialog');
      if (topicSearchDialog) {
        topicSearchDialog.addEventListener('click', e => {
          if (e.target === topicSearchDialog) closeDialog(topicSearchDialog);
        });
      }
      const toggleTopicSelectBtn = el('toggleTopicSelectBtn');
      if (toggleTopicSelectBtn) {
        toggleTopicSelectBtn.onclick = () => {
          setTopicSelectionMode(!topicSelectionMode);
          loadTopics();
        };
      }
      const openTopicSearchBtn = el('openTopicSearchBtn');
      if (openTopicSearchBtn) openTopicSearchBtn.onclick = openTopicSearchModal;
      const closeTopicSearchBtn = el('closeTopicSearchBtn');
      if (closeTopicSearchBtn) closeTopicSearchBtn.onclick = () => closeDialog(el('topicSearchDialog'));
      const runTopicSearchBtn = el('runTopicSearchBtn');
      if (runTopicSearchBtn) runTopicSearchBtn.onclick = runTopicSearch;
      const topicSearchInput = el('topicSearchInput');
      if (topicSearchInput) {
        topicSearchInput.addEventListener('keydown', e => {
          if (e.key !== 'Enter') return;
          e.preventDefault();
          runTopicSearch();
        });
      }
      const cancelTopicSelectionBtn = el('cancelTopicSelectionBtn');
      if (cancelTopicSelectionBtn) {
        cancelTopicSelectionBtn.onclick = () => {
          setTopicSelectionMode(false);
          loadTopics();
        };
      }
      const deleteSelectedTopicsBtn = el('deleteSelectedTopicsBtn');
      if (deleteSelectedTopicsBtn) deleteSelectedTopicsBtn.onclick = deleteSelectedTopics;
      const moveSelectedTopicsBtn = el('moveSelectedTopicsBtn');
      if (moveSelectedTopicsBtn) moveSelectedTopicsBtn.onclick = openMoveTopicsDialog;
      const confirmMoveTopicsBtn = el('confirmMoveTopicsBtn');
      if (confirmMoveTopicsBtn) confirmMoveTopicsBtn.onclick = moveSelectedTopics;
      const cancelMoveTopicsBtn = el('cancelMoveTopicsBtn');
      if (cancelMoveTopicsBtn) cancelMoveTopicsBtn.onclick = () => closeDialog(el('moveTopicsDialog'));
      updateTopicSelectionUi();

      const sidebar = document.querySelector('.sidebar');
      const sidebarToggle = el('sidebarToggle');
      const sidebarToggleHome = el('sidebarToggleHome');
      const sidebarToggleButtons = [sidebarToggle, sidebarToggleHome].filter(Boolean);
      const sidebarOverlay = el('sidebarOverlay');
      sidebarToggleButtons.forEach(toggleBtn => {
        toggleBtn.onclick = () => document.body.classList.toggle('sidebar-open');
      });
      if (sidebarOverlay) {
        sidebarOverlay.onclick = () => document.body.classList.remove('sidebar-open');
      }
      document.addEventListener('click', e => {
        if (!document.body.classList.contains('sidebar-open')) return;
        const target = e.target;
        if (!(target instanceof Element)) return;
        if (sidebarToggleButtons.some(toggleBtn => toggleBtn.contains(target))) return;
        if (sidebar && sidebar.contains(target)) return;
        document.body.classList.remove('sidebar-open');
      });
      window.addEventListener('resize', () => {
        if (window.innerWidth > 768) document.body.classList.remove('sidebar-open');
      });

      const editorShell = document.querySelector('#editorPanel .editor-shell');
      const editorOverlay = el('editorOverlay');
      const toggleSidebarBtn = el('toggleEditorSidebarBtn');
      if (toggleSidebarBtn && editorShell) {
        toggleSidebarBtn.onclick = () => editorShell.classList.toggle('sidebar-open');
      }
      if (editorOverlay && editorShell) {
        editorOverlay.onclick = () => editorShell.classList.remove('sidebar-open');
      }
      window.addEventListener('resize', () => {
        if (window.innerWidth > 980 && editorShell) editorShell.classList.remove('sidebar-open');
        if (currentView !== 3 && editorShell) editorShell.classList.remove('sidebar-open');
      });
      window.addEventListener('resize', scheduleOverviewTableFit);
      el('closeEditCardBtn').onclick = () => el('editCardDialog').close();
      el('editAddMcqOptionBtn').onclick = () => {
        setMcqModeState(true, true);
        addEditMcqRow();
        syncMcqPrimaryAnswerMode(true);
      };
      el('openCreateCardBtn').onclick = openCreateCardEditor;
      el('addMcqOptionBtn').onclick = () => {
        setMcqModeState(false, true);
        addMcqRow();
        syncMcqPrimaryAnswerMode(false);
      };
      attachAutoClose(el('cardPrompt'));
      attachAutoClose(el('cardAnswer'));
      attachAutoClose(el('editCardPrompt'));
      attachAutoClose(el('editCardAnswer'));
      [el('cardAnswer'), el('editCardAnswer')].forEach(input => {
        if (!(input instanceof HTMLTextAreaElement)) return;
        input.addEventListener('keydown', handlePrimaryMcqAnswerKeydown);
        input.addEventListener('input', () => enforcePrimaryMcqAnswerSingleLine(input));
      });
      ['dragover', 'drop'].forEach(evt => {
        document.addEventListener(evt, e => {
          e.preventDefault();
        }, true);
      });
      const createShortcut = e => {
        if (e.key === 'Enter' && e.shiftKey) {
          e.preventDefault();
          el('addCardBtn').click();
        }
      };
      el('cardPrompt').addEventListener('keydown', createShortcut);
      el('cardAnswer').addEventListener('keydown', createShortcut);
      el('cardPrompt').addEventListener('input', () => updateCreateValidation());
      el('cardAnswer').addEventListener('input', () => updateCreateValidation());
      wireLivePreview('cardPrompt', 'questionPreview', () => createQuestionTextAlign);
      wireLivePreview('cardAnswer', 'answerPreview', () => createAnswerTextAlign);
      const saveShortcut = e => {
        if (e.key === 'Enter' && e.shiftKey) {
          e.preventDefault();
          el('saveEditCardBtn').click();
        }
      };
      el('editCardPrompt').addEventListener('keydown', saveShortcut);
      el('editCardAnswer').addEventListener('keydown', saveShortcut);
      wireLivePreview('editCardPrompt', 'editQuestionPreview', () => editQuestionTextAlign);
      wireLivePreview('editCardAnswer', 'editAnswerPreview', () => editAnswerTextAlign);
      wireTextFormattingToolbar();
      document.querySelectorAll('.formula-btn').forEach(btn => {
        btn.onclick = () => openFormulaDialog(btn.dataset.formulaTarget);
      });
      const formulaDialog = el('formulaDialog');
      if (formulaDialog) {
        formulaDialog.addEventListener('click', e => {
          if (e.target === formulaDialog) formulaDialog.close();
        });
      }
      const closeFormulaBtn = el('closeFormulaBtn');
      const cancelFormulaBtn = el('cancelFormulaBtn');
      if (closeFormulaBtn) closeFormulaBtn.onclick = () => formulaDialog?.close();
      if (cancelFormulaBtn) cancelFormulaBtn.onclick = () => formulaDialog?.close();
      const formulaInput = el('formulaInput');
      const formulaDisplayToggle = el('formulaDisplayToggle');
      const insertFormulaBtn = el('insertFormulaBtn');
      const debouncedFormulaPreview = debounce(renderFormulaPreview, 300);
      if (formulaInput) formulaInput.addEventListener('input', debouncedFormulaPreview);
      if (formulaDisplayToggle) formulaDisplayToggle.addEventListener('change', renderFormulaPreview);
      if (insertFormulaBtn) insertFormulaBtn.onclick = insertFormulaImage;
      const tableDialog = el('tableDialog');
      if (tableDialog) {
        tableDialog.addEventListener('click', e => {
          if (e.target === tableDialog) closeDialog(tableDialog);
        });
        tableDialog.addEventListener('input', handleTableBuilderInput);
        tableDialog.addEventListener('focusin', handleTableBuilderSelection);
        tableDialog.addEventListener('click', handleTableBuilderSelection);
        tableDialog.addEventListener('keydown', e => {
          if (e.key !== 'Enter' || !(e.metaKey || e.ctrlKey) || e.shiftKey || e.altKey) return;
          e.preventDefault();
          insertTableFromDialog();
        });
      }
      const closeTableBtn = el('closeTableBtn');
      const cancelTableBtn = el('cancelTableBtn');
      const insertTableBtn = el('insertTableBtn');
      const tableRowsInput = el('tableRowsInput');
      const tableColsInput = el('tableColsInput');
      const tableHeaderToggle = el('tableHeaderToggle');
      const tableRowsDownBtn = el('tableRowsDownBtn');
      const tableRowsUpBtn = el('tableRowsUpBtn');
      const tableColsDownBtn = el('tableColsDownBtn');
      const tableColsUpBtn = el('tableColsUpBtn');
      const tableAlignLeftBtn = el('tableAlignLeftBtn');
      const tableAlignCenterBtn = el('tableAlignCenterBtn');
      const tableAlignRightBtn = el('tableAlignRightBtn');
      if (closeTableBtn) closeTableBtn.onclick = () => closeDialog(el('tableDialog'));
      if (cancelTableBtn) cancelTableBtn.onclick = () => closeDialog(el('tableDialog'));
      if (insertTableBtn) insertTableBtn.onclick = insertTableFromDialog;
      if (tableRowsInput) tableRowsInput.addEventListener('input', updateTableBuilderFromControls);
      if (tableColsInput) tableColsInput.addEventListener('input', updateTableBuilderFromControls);
      if (tableHeaderToggle) tableHeaderToggle.addEventListener('change', updateTableBuilderFromControls);
      if (tableRowsDownBtn) tableRowsDownBtn.onclick = () => stepTableBuilderSize('rows', -1);
      if (tableRowsUpBtn) tableRowsUpBtn.onclick = () => stepTableBuilderSize('rows', 1);
      if (tableColsDownBtn) tableColsDownBtn.onclick = () => stepTableBuilderSize('cols', -1);
      if (tableColsUpBtn) tableColsUpBtn.onclick = () => stepTableBuilderSize('cols', 1);
      if (tableAlignLeftBtn) tableAlignLeftBtn.onclick = () => applyTableBuilderSelectedAlignment('left');
      if (tableAlignCenterBtn) tableAlignCenterBtn.onclick = () => applyTableBuilderSelectedAlignment('center');
      if (tableAlignRightBtn) tableAlignRightBtn.onclick = () => applyTableBuilderSelectedAlignment('right');
      attachImageDrop(el('cardPrompt'), dataUrls => {
        appendImagesToField(
          el('cardPrompt'),
          el('questionImagePreview'),
          dataUrls,
          'imageDataQ',
          updateCreateValidation
        );
      });
      attachImageDrop(el('questionImagePreview'), dataUrls => {
        appendImagesToField(
          el('cardPrompt'),
          el('questionImagePreview'),
          dataUrls,
          'imageDataQ',
          updateCreateValidation
        );
      });
      attachImagePicker(el('questionImagePreview'), dataUrls => {
        appendImagesToField(
          el('cardPrompt'),
          el('questionImagePreview'),
          dataUrls,
          'imageDataQ',
          updateCreateValidation
        );
      });
      attachImageDrop(el('cardAnswer'), dataUrls => {
        appendImagesToField(
          el('cardAnswer'),
          el('answerImagePreview'),
          dataUrls,
          'imageDataA',
          updateCreateValidation
        );
      });
      attachImageDrop(el('answerImagePreview'), dataUrls => {
        appendImagesToField(
          el('cardAnswer'),
          el('answerImagePreview'),
          dataUrls,
          'imageDataA',
          updateCreateValidation
        );
      });
      attachImagePicker(el('answerImagePreview'), dataUrls => {
        appendImagesToField(
          el('cardAnswer'),
          el('answerImagePreview'),
          dataUrls,
          'imageDataA',
          updateCreateValidation
        );
      });
      attachImageDrop(el('editCardPrompt'), dataUrls => {
        appendImagesToField(el('editCardPrompt'), el('editQuestionImagePreview'), dataUrls, 'imageDataQ');
      });
      attachImageDrop(el('editQuestionImagePreview'), dataUrls => {
        appendImagesToField(el('editCardPrompt'), el('editQuestionImagePreview'), dataUrls, 'imageDataQ');
      });
      attachImagePicker(el('editQuestionImagePreview'), dataUrls => {
        appendImagesToField(el('editCardPrompt'), el('editQuestionImagePreview'), dataUrls, 'imageDataQ');
      });
      attachImageDrop(el('editCardAnswer'), dataUrls => {
        appendImagesToField(el('editCardAnswer'), el('editAnswerImagePreview'), dataUrls, 'imageDataA');
      });
      attachImageDrop(el('editAnswerImagePreview'), dataUrls => {
        appendImagesToField(el('editCardAnswer'), el('editAnswerImagePreview'), dataUrls, 'imageDataA');
      });
      attachImagePicker(el('editAnswerImagePreview'), dataUrls => {
        appendImagesToField(el('editCardAnswer'), el('editAnswerImagePreview'), dataUrls, 'imageDataA');
      });

      el('cancelSubjectBtn').onclick = () => closeDialog(el('subjectDialog'));
      el('createSubjectBtn').onclick = addSubjectFromDialog;
      el('cancelSubjectEditBtn').onclick = () => el('subjectEditDialog').close();
      el('saveSubjectEditBtn').onclick = async () => {
        if (!editingSubjectId) return;
        const name = el('editSubjectName').value.trim();
        const accent = el('editSubjectColor').value || '#2dd4bf';
        if (!name) return;
        const existingSubject = (await getAll('subjects')).find(subject => subject.id === editingSubjectId);
        if (!existingSubject) return;
        const updatedSubject = buildSubjectRecord(existingSubject, { name, accent });
        await put('subjects', updatedSubject);
        if (selectedSubject?.id === editingSubjectId) {
          selectedSubject = { ...selectedSubject, ...updatedSubject };
          applySubjectTheme(accent);
        }
        editingSubjectId = null;
        el('subjectEditDialog').close();
        refreshSidebar();
        if (selectedSubject) loadTopics();
      };
      el('deleteSubjectBtn').onclick = async () => {
        if (!editingSubjectId) return;
        if (!confirm('Delete this subject and all its topics/cards?')) return;
        const id = editingSubjectId;
        editingSubjectId = null;
        el('subjectEditDialog').close();
        await deleteSubjectById(id);
      };

      el('subjectAccentPicker').addEventListener('input', e => {
        el('subjectAccentText').value = e.target.value;
      });
      el('subjectAccentText').addEventListener('input', e => {
        const v = e.target.value.trim();
        if (/^#([0-9a-fA-F]{3}){1,2}$/.test(v)) el('subjectAccentPicker').value = v;
      });
      el('subjectPalette').addEventListener('click', e => {
        const btn = e.target.closest('button[data-color]');
        if (!btn) return;
        const c = btn.dataset.color;
        el('subjectAccentPicker').value = c;
        el('subjectAccentText').value = c;
      });

      // subject accent editing moved to subject edit dialog

      const sessionMinus = el('sessionMinus');
      const sessionPlus = el('sessionPlus');
      const sessionSizeValue = el('sessionSizeValue');
      if (sessionMinus && sessionPlus && sessionSizeValue) {
        sessionMinus.onclick = () => {
          if (availableSessionCards <= 0) {
            sessionSize = 0;
            renderSessionSizeCounter();
            return;
          }
          sessionSize = Math.max(1, sessionSize - 1);
          renderSessionSizeCounter();
        };
        sessionPlus.onclick = () => {
          if (availableSessionCards <= 0) {
            sessionSize = 0;
            renderSessionSizeCounter();
            return;
          }
          sessionSize = Math.min(availableSessionCards, sessionSize + 1);
          renderSessionSizeCounter();
        };
        renderSessionSizeCounter();
      }

      const addTopicFromInput = async () => {
        if (!selectedSubject) return alert('Pick a subject first.');
        const name = el('topicName').value.trim();
        if (!name) return;
        await put('topics', { id: uid(), subjectId: selectedSubject.id, name });
        await touchSubject(selectedSubject.id);
        el('topicName').value = '';
        loadTopics();
        refreshSidebar();
      };
      el('addTopicBtn').onclick = addTopicFromInput;
      el('topicName').addEventListener('keydown', e => {
        if (e.key !== 'Enter') return;
        e.preventDefault();
        addTopicFromInput();
      });

      el('addCardBtn').onclick = async () => {
        if (!selectedTopic) return alert('Pick a topic first.');
        if (!updateCreateValidation(true)) {
          createTouched = true;
          updateCreateValidation(true);
          return;
        }
        const imagesQ = getFieldImageList(el('cardPrompt'), 'imageDataQ');
        const imagesA = getFieldImageList(el('cardAnswer'), 'imageDataA');
        const imagePayload = getCardImagePayload(imagesQ, imagesA);
        const options = parseMcqOptions();
        const type = options.length > 1 ? 'mcq' : 'qa';
        const createdAt = new Date().toISOString();
        const card = {
          id: uid(),
          topicId: selectedTopic.id,
          type,
          textAlign: normalizeTextAlign(createQuestionTextAlign),
          questionTextAlign: normalizeTextAlign(createQuestionTextAlign),
          answerTextAlign: normalizeTextAlign(createAnswerTextAlign),
          optionsTextAlign: normalizeTextAlign(createOptionsTextAlign),
          prompt: el('cardPrompt').value,
          answer: el('cardAnswer').value,
          options: type === 'mcq' ? options : [],
          ...imagePayload,
          createdAt,
          meta: { createdAt }
        };
        await put('cards', card);
        await putCardBank(card);
        if (selectedSubject?.id) await touchSubject(selectedSubject.id);
        el('cardPrompt').value = '';
        el('cardAnswer').value = '';
        replaceFieldImages(el('cardPrompt'), el('questionImagePreview'), [], 'imageDataQ', updateCreateValidation);
        replaceFieldImages(el('cardAnswer'), el('answerImagePreview'), [], 'imageDataA', updateCreateValidation);
        const primaryToggle = el('primaryAnswerToggle');
        if (primaryToggle) primaryToggle.checked = true;
        el('mcqOptions').innerHTML = '';
        setMcqModeState(false, false);
        createTouched = false;
        updateCreateValidation();
        applyCreateQuestionTextAlign('center');
        applyCreateAnswerTextAlign('center');
        applyCreateOptionsTextAlign('left');
        loadEditorCards();
        loadDeck();
        refreshSidebar();
      };

      el('saveEditCardBtn').onclick = async () => {
        if (!editingCardId) return;
        const card = await getById('cards', editingCardId);
        if (!card) return;
        const createdAt = card?.meta?.createdAt || card?.createdAt || new Date().toISOString();
        const updatedAt = new Date().toISOString();
        const imagesQ = getFieldImageList(el('editCardPrompt'), 'imageDataQ');
        const imagesA = getFieldImageList(el('editCardAnswer'), 'imageDataA');
        const imagePayload = getCardImagePayload(imagesQ, imagesA);
        const options = parseEditMcqOptions();
        const type = options.length > 1 ? 'mcq' : 'qa';
        const updated = {
          ...card,
          createdAt,
          meta: {
            ...(card.meta || {}),
            createdAt,
            updatedAt
          },
          textAlign: normalizeTextAlign(editQuestionTextAlign),
          questionTextAlign: normalizeTextAlign(editQuestionTextAlign),
          answerTextAlign: normalizeTextAlign(editAnswerTextAlign),
          optionsTextAlign: normalizeTextAlign(editOptionsTextAlign),
          prompt: el('editCardPrompt').value,
          answer: el('editCardAnswer').value,
          options: type === 'mcq' ? options : [],
          type,
          ...imagePayload
        };
        await put('cards', updated);
        await putCardBank(updated);
        await touchSubjectByTopicId(updated.topicId);
        if (session.active) {
          const idx = session.activeQueue.findIndex(c => c.id === updated.id);
          if (idx !== -1) session.activeQueue[idx] = { ...session.activeQueue[idx], ...updated };
          const mIdx = session.mastered.findIndex(c => c.id === updated.id);
          if (mIdx !== -1) session.mastered[mIdx] = { ...session.mastered[mIdx], ...updated };
        }
        el('editCardDialog').close();
        replaceFieldImages(el('editCardPrompt'), el('editQuestionImagePreview'), [], 'imageDataQ');
        replaceFieldImages(el('editCardAnswer'), el('editAnswerImagePreview'), [], 'imageDataA');
        editingCardId = null;
        loadDeck();
        loadEditorCards();
        refreshSidebar();
        renderSessionCard();
        setPreview('editQuestionPreview', '', editQuestionTextAlign);
        setPreview('editAnswerPreview', '', editAnswerTextAlign);
      };

      document.querySelectorAll('[data-grade]').forEach(btn => {
        btn.addEventListener('click', () => gradeCard(btn.dataset.grade));
      });

      ensureKatexLoaded().then(loaded => {
        if (!loaded) return;
        rerenderAllRichMath();
      });
      await refreshSidebar();
      await refreshDailyReviewHomePanel({ useExisting: false });
    }

    window.addEventListener('DOMContentLoaded', boot);
  </script>

  <dialog id="subjectDialog" class="modal">
    <h3>New Subject</h3>
    <div class="grid two">
      <div>
        <label>Subject Name</label>
        <input class="input" id="subjectNameInput" placeholder="e.g., Fluid Mechanics" />
      </div>
      <div>
        <label>Accent Color</label>
        <input class="input" type="color" id="subjectAccentPicker" value="#2dd4bf" />
      </div>
    </div>
    <label>Accent Hex</label>
    <input class="input" id="subjectAccentText" value="#2dd4bf" />
    <div class="tiny" style="margin:6px 0 10px;">Pick a color or paste a hex value.</div>
    <div class="palette" id="subjectPalette">
      <button type="button" data-color="#2dd4bf" style="background:#2dd4bf"></button>
      <button type="button" data-color="#22c55e" style="background:#22c55e"></button>
      <button type="button" data-color="#f59e0b" style="background:#f59e0b"></button>
      <button type="button" data-color="#ef4444" style="background:#ef4444"></button>
      <button type="button" data-color="#60a5fa" style="background:#60a5fa"></button>
      <button type="button" data-color="#a855f7" style="background:#a855f7"></button>
      <button type="button" data-color="#f472b6" style="background:#f472b6"></button>
    </div>
    <div class="controls" style="margin-top:14px;">
      <button class="btn" id="createSubjectBtn">Create Subject</button>
      <button class="btn" id="cancelSubjectBtn">Cancel</button>
    </div>
  </dialog>

  <dialog id="subjectEditDialog" class="modal">
    <h3>Edit Subject</h3>
    <div class="grid two">
      <div>
        <label>Name</label>
        <input id="editSubjectName" placeholder="e.g., Fluid Mechanics" />
      </div>
      <div>
        <label>Accent Color</label>
        <input type="color" id="editSubjectColor" value="#2dd4bf" />
      </div>
    </div>
    <div class="controls" style="margin-top:12px; margin-inline: 0">
      <button class="btn save-primary" id="saveSubjectEditBtn">Save</button>
      <button class="btn delete" id="deleteSubjectBtn" style="width: 48%">Delete</button>
      <button class="btn" id="cancelSubjectEditBtn" style="width: 46%">Cancel</button>
    </div>
  </dialog>

  <dialog id="moveCardsDialog" class="modal">
    <h3>Karten verschieben</h3>
    <div class="tiny" id="moveCardsSelectionInfo" style="margin-bottom:10px;">0 Karten ausgew√§hlt</div>
    <div class="grid two">
      <div>
        <label>Subject</label>
        <select id="moveCardsSubjectSelect"></select>
      </div>
      <div>
        <label>Topic</label>
        <select id="moveCardsTopicSelect"></select>
      </div>
    </div>
    <div class="controls" style="margin-top:12px; margin-inline: 0">
      <button class="btn" id="confirmMoveCardsBtn" type="button">Verschieben</button>
      <button class="btn" id="cancelMoveCardsBtn" type="button">Abbrechen</button>
    </div>
  </dialog>

  <dialog id="moveTopicsDialog" class="modal">
    <h3>Move Topics</h3>
    <div class="tiny" id="moveTopicsSelectionInfo" style="margin-bottom:10px;">0 topics selected</div>
    <div>
      <label>Target Subject</label>
      <select id="moveTopicsSubjectSelect"></select>
    </div>
    <div class="controls" style="margin-top:12px; margin-inline: 0">
      <button class="btn" id="confirmMoveTopicsBtn" type="button">Move</button>
      <button class="btn" id="cancelMoveTopicsBtn" type="button">Cancel</button>
    </div>
  </dialog>

  <dialog id="topicSearchDialog" class="modal modal-wide" style="padding-bottom: 0;">
    <div class="topic-search-sticky-head">
      <div class="editor-header">
        <h3>Search Cards</h3>
        <button class="btn close-icon-btn" id="closeTopicSearchBtn" type="button" aria-label="Close search dialog"
          title="Close">
          <img src="icons/close.svg" alt="" aria-hidden="true" />
        </button>
      </div>
      <div class="topic-search-controls">
        <input id="topicSearchInput" type="text" placeholder="Search in question and answer text..." />
        <button class="btn" id="runTopicSearchBtn" type="button">Search</button>
      </div>
      <div class="tiny" id="topicSearchMeta">Enter a search term.</div>
    </div>
    <div id="topicSearchResults" class="card-grid topic-search-results"></div>
  </dialog>

  <dialog id="progressCheckDialog" class="modal modal-wide progress-check-dialog">
    <div class="topic-search-sticky-head progress-check-sticky-head">
      <div class="editor-header">
        <h3>Cards Status Check</h3>
        <button class="btn close-icon-btn" id="closeProgressCheckBtn" type="button"
          aria-label="Close progress check dialog" title="Close">
          <img src="icons/close.svg" alt="" aria-hidden="true" />
        </button>
      </div>
      <div class="controls" style="margin:0; margin-top:8px; justify-content: space-between; width: 100%;">
        <div class="tiny" id="progressCheckMeta">Loading...</div>
        <button class="btn" id="refreshProgressCheckBtn" type="button">Refresh</button>
      </div>
    </div>
    <div class="progress-check-table-wrap">
      <table class="progress-check-table" id="progressCheckTable">
        <thead>
          <tr>
            <th>Subject</th>
            <th>Topic</th>
            <th>Question</th>
            <th>Current</th>
            <th>Streak</th>
            <th>Last Grade</th>
            <th>Last Answered</th>
            <th>Totals (C/P/W)</th>
            <th>History</th>
          </tr>
        </thead>
        <tbody id="progressCheckTableBody"></tbody>
      </table>
    </div>
  </dialog>

  <dialog id="sessionFilterDialog" class="modal">
    <h3>Session Filter</h3>
    <div class="session-filter-list">
      <label class="session-filter-option">
        <input id="sessionFilterAll" type="checkbox" />
        <span>All (remaining today)</span>
      </label>
      <label class="session-filter-option">
        <input id="sessionFilterCorrect" type="checkbox" />
        <span>Correctly answered (mastered)</span>
      </label>
      <label class="session-filter-option">
        <input id="sessionFilterWrong" type="checkbox" />
        <span>Wrong</span>
      </label>
      <label class="session-filter-option">
        <input id="sessionFilterPartial" type="checkbox" />
        <span>Not quite / In progress</span>
      </label>
      <label class="session-filter-option">
        <input id="sessionFilterNotAnswered" type="checkbox" />
        <span>Not answered today</span>
      </label>
    </div>
    <div class="tiny" style="margin-top:10px;">All mode excludes cards mastered today (3x correct in a row).</div>
    <div class="controls" style="margin-top:12px; margin-inline: 0">
      <button class="btn" id="saveSessionFilterBtn" type="button">Apply</button>
      <button class="btn" id="cancelSessionFilterBtn" type="button">Cancel</button>
    </div>
  </dialog>

  <dialog id="sessionCompleteDialog" class="modal">
    <div class="editor-header">
      <h3>Session Complete</h3>
      <button class="btn close-icon-btn" id="closeSessionCompleteBtn" type="button"
        aria-label="Close session complete dialog" title="Close">
        <img src="icons/close.svg" alt="" aria-hidden="true" />
      </button>
    </div>
    <div class="session-complete-message" id="sessionCompleteMessage">Great work!</div>
    <div class="session-complete-stats">
      <div class="session-complete-stat">
        <div class="tiny">Time</div>
        <strong id="sessionCompleteDuration">0:00</strong>
      </div>
      <div class="session-complete-stat">
        <div class="tiny">Remaining Cards</div>
        <strong id="sessionCompleteRemaining">0</strong>
      </div>
    </div>
    <div class="session-repeat-controls">
      <div class="tiny">Next Session Size</div>
      <div class="counter">
        <button class="btn counter-btn" id="sessionRepeatMinus" type="button">-</button>
        <div class="counter-value" id="sessionRepeatSizeValue">0 / 0</div>
        <button class="btn counter-btn" id="sessionRepeatPlus" type="button">+</button>
      </div>
    </div>
    <div class="controls" style="margin-top:14px; margin-inline: 0">
      <button class="btn" id="startAnotherSessionBtn" type="button" style="width:100%;">Start Another Session</button>
    </div>
  </dialog>

  <dialog id="settingsDialog" class="modal">
    <div class="editor-header">
      <h3>Settings & Data</h3>
      <button class="btn close-icon-btn" id="closeSettingsBtn" type="button"
        onclick="document.getElementById('settingsDialog').close()" aria-label="Close settings dialog" title="Close">
        <img src="icons/close.svg" alt="" aria-hidden="true" />
      </button>
    </div>
    <p class="tiny">Export and import your shared server dataset.</p>
    <div class="controls">
      <button class="btn" onclick="exportJSON()">Export JSON</button>
      <button class="btn" onclick="exportCSV()">Export CSV</button>
      <button class="btn" id="openProgressCheckFromSettingsBtn" type="button">‚úì Check Status</button>
      <label class="btn" for="importInput">Import JSON</label>
      <input id="importInput" type="file" accept="application/json" class="hidden" />
    </div>
    <script>
      document.getElementById('importInput').addEventListener('change', e => {
        const file = e.target.files[0];
        if (file) importJSON(file);
      });
    </script>
  </dialog>

  <dialog id="editCardDialog" class="modal modal-wide">
    <div class="editor-header">
      <h3>Edit Flashcard</h3>
      <button class="btn close-icon-btn" id="closeEditCardBtn" type="button" aria-label="Close edit card dialog"
        title="Close">
        <img src="icons/close.svg" alt="" aria-hidden="true" />
      </button>
    </div>
    <div class="editor-grid editor-grid-single">
      <div class="editor-panel editor-main">
        <div class="editor-main-scroll">
          <div class="editor-field">
            <div class="field-head">
              <label>Question</label>
              <!-- <button class="btn btn-small formula-btn" data-formula-target="editCardPrompt" type="button">Formula</button> -->
            </div>
            <div class="editor-input-media-row">
              <textarea id="editCardPrompt" placeholder="Type your question..."></textarea>
              <div id="editQuestionImagePreview" class="image-preview">Drop image here</div>
            </div>
            <div class="text-toolbar" data-group="edit-question">
              <div class="toolbar-segment">
                <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                  data-group="edit-question" data-align="left" aria-label="Align left"
                  title="Align left (Cmd/Ctrl+L)"><img src="icons/links.png" alt=""></button>
                <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                  data-group="edit-question" data-align="center" aria-label="Align center"
                  title="Align center (Cmd/Ctrl+C)"><img src="icons/center.png" alt=""></button>
                <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                  data-group="edit-question" data-align="justify" aria-label="Align justify"
                  title="Align justify (Cmd/Ctrl+J)"><img src="icons/rechts.png" alt=""></button>
              </div>
              <div class="toolbar-segment">
                <button class="btn btn-small toolbar-btn" type="button" data-action="list" data-target="editCardPrompt"
                  data-list="ul">‚Ä¢ List</button>
                <button class="btn btn-small toolbar-btn" type="button" data-action="list" data-target="editCardPrompt"
                  data-list="ol">1. List</button>
                <button class="btn btn-small toolbar-btn" type="button" data-action="table"
                  data-target="editCardPrompt">Table</button>
              </div>
            </div>
          </div>
          <!-- <div class="qa-editor-separator" aria-hidden="true"></div> -->
          <hr style="border-color:#30456f;width: 97%;">
          <div class="editor-field" id="editAnswerField">
            <div class="mcq-primary-row" id="editPrimaryAnswerRow">
              <div class="mcq-primary-header hidden" id="editPrimaryAnswerHeader">
                <span class="mcq-badge correct" id="editPrimaryAnswerBadge">Correct Answer ‚úì</span>
                <label class="toggle mcq-toggle">
                  <input type="checkbox" id="editPrimaryAnswerToggle" checked />
                  <span class="toggle-slider"></span>
                </label>
              </div>
              <div class="field-head">
                <label>Answer</label>
                <!-- <button class="btn btn-small formula-btn" data-formula-target="editCardAnswer" type="button">Formula</button> -->
              </div>
              <div class="editor-input-media-row">
                <textarea id="editCardAnswer" placeholder="Type the answer..."></textarea>
                <div id="editAnswerImagePreview" class="image-preview">Drop image here</div>
              </div>
              <div class="text-toolbar" data-group="edit-answer">
                <div class="toolbar-segment">
                  <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                    data-group="edit-answer" data-align="left" aria-label="Align left"
                    title="Align left (Cmd/Ctrl+L)"><img src="icons/links.png" alt=""></button>
                  <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                    data-group="edit-answer" data-align="center" aria-label="Align center"
                    title="Align center (Cmd/Ctrl+C)"><img src="icons/center.png" alt=""></button>
                  <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                    data-group="edit-answer" data-align="justify" aria-label="Align justify"
                    title="Align justify (Cmd/Ctrl+J)"><img src="icons/rechts.png" alt=""></button>
                </div>
                <div class="toolbar-segment">
                  <button class="btn btn-small toolbar-btn" type="button" data-action="list"
                    data-target="editCardAnswer" data-list="ul">‚Ä¢ List</button>
                  <button class="btn btn-small toolbar-btn" type="button" data-action="list"
                    data-target="editCardAnswer" data-list="ol">1. List</button>
                  <button class="btn btn-small toolbar-btn" type="button" data-action="table"
                    data-target="editCardAnswer">Table</button>
                </div>
              </div>
            </div>
            <div class="editor-options">
              <div class="tiny">Multi-select answers (optional)</div>
              <div class="text-toolbar hidden" id="editOptionsToolbar" data-group="edit-options">
                <div class="toolbar-segment">
                  <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                    data-group="edit-options" data-align="left" aria-label="Options align left"
                    title="Options align left"><img src="icons/links.png" alt=""></button>
                  <button class="btn btn-small toolbar-btn align-icon-btn" type="button" data-action="align"
                    data-group="edit-options" data-align="center" aria-label="Options align center"
                    title="Options align center"><img src="icons/center.png" alt=""></button>
                </div>
              </div>
              <div id="editMcqOptions" class="hidden"></div>
              <button class="btn" id="editAddMcqOptionBtn">Add Answer</button>
            </div>
          </div>
        </div>
        <div class="editor-footer">
          <button class="btn save-primary" id="saveEditCardBtn" style="position: sticky; bottom: 0;">Save
            Changes</button>
        </div>
      </div>
    </div>
  </dialog>

  <dialog id="cardPreviewDialog" class="modal modal-wide card-preview-dialog">
    <div class="editor-header">
      <h3>Study Preview</h3>
      <button class="btn close-icon-btn" id="closeCardPreviewBtn" type="button" aria-label="Close study preview"
        title="Close">
        <img src="icons/close.svg" alt="" aria-hidden="true" />
      </button>
    </div>
    <div class="tiny">Tap the card to flip. Space also flips.</div>
    <div class="card-preview-shell">
      <div class="flash-area card-preview-area">
        <div id="previewFlashcard" class="flashcard">
          <div class="face">
            <div class="card-corner-label">Question</div>
            <div class="study-topic-pill face-topic-pill hidden" id="previewFrontTopicPill"></div>
            <div class="face-content" id="previewFrontContent"></div>
          </div>
          <div class="face back">
            <div class="card-corner-label">Answer</div>
            <div class="study-topic-pill face-topic-pill hidden" id="previewBackTopicPill"></div>
            <div class="face-content" id="previewBackContent"></div>
          </div>
        </div>
      </div>
    </div>
  </dialog>

  <dialog id="tableDialog" class="modal modal-table-builder">
    <div class="editor-header">
      <h3>Table Generator</h3>
      <button class="btn close-icon-btn" id="closeTableBtn" type="button" aria-label="Close table dialog" title="Close">
        <img src="icons/close.svg" alt="" aria-hidden="true" />
      </button>
    </div>
    <div class="tiny" id="tableTargetLabel">Target: Question</div>
    <div class="table-builder-controls">
      <div class="table-builder-size">
        <label for="tableRowsInput">Rows</label>
        <div class="table-builder-stepper">
          <button class="btn btn-small" id="tableRowsDownBtn" type="button" aria-label="Decrease rows">-</button>
          <input id="tableRowsInput" type="number" min="1" max="20" step="1" value="3" />
          <button class="btn btn-small" id="tableRowsUpBtn" type="button" aria-label="Increase rows">+</button>
        </div>
      </div>
      <div class="table-builder-size">
        <label for="tableColsInput">Columns</label>
        <div class="table-builder-stepper">
          <button class="btn btn-small" id="tableColsDownBtn" type="button" aria-label="Decrease columns">-</button>
          <input id="tableColsInput" type="number" min="1" max="10" step="1" value="3" />
          <button class="btn btn-small" id="tableColsUpBtn" type="button" aria-label="Increase columns">+</button>
        </div>
      </div>
      <div class="table-builder-header-toggle">
        <span>Header</span>
        <label class="toggle">
          <input id="tableHeaderToggle" type="checkbox" checked />
          <span class="toggle-slider"></span>
        </label>
      </div>
      <div class="table-builder-align" role="group" aria-label="Selected cell alignment">
        <div class="tiny" id="tableCellSelectionLabel">Cell: none selected</div>
        <div class="table-builder-align-buttons">
          <button class="btn btn-small toolbar-btn table-builder-align-btn align-icon-btn" id="tableAlignLeftBtn"
            type="button" data-align="left" aria-label="Align selected cell left"><img src="icons/links.png"
              alt=""></button>
          <button class="btn btn-small toolbar-btn table-builder-align-btn align-icon-btn" id="tableAlignCenterBtn"
            type="button" data-align="center" aria-label="Align selected cell center"><img src="icons/center.png"
              alt=""></button>
          <button class="btn btn-small toolbar-btn table-builder-align-btn align-icon-btn" id="tableAlignRightBtn"
            type="button" data-align="right" aria-label="Align selected cell right"><img src="icons/rechts.png"
              alt=""></button>
        </div>
      </div>
    </div>
    <div class="tiny table-builder-help">Edit cells directly. Click a cell, then choose left/center/right. Use
      Cmd/Ctrl + Enter to insert.</div>
    <div id="tableBuilderGrid" class="table-builder-grid" role="region" aria-label="Editable table grid"></div>
    <div class="controls" style="margin-top:12px; margin-inline: 0">
      <button class="btn" id="insertTableBtn" type="button">Insert Table</button>
      <button class="btn" id="cancelTableBtn" type="button">Cancel</button>
    </div>
  </dialog>

  <dialog id="formulaDialog" class="modal modal-wide">
    <div class="editor-header">
      <h3>Formula Editor</h3>
      <button class="btn close-icon-btn" id="closeFormulaBtn" type="button" aria-label="Close formula dialog"
        title="Close">
        <img src="icons/close.svg" alt="" aria-hidden="true" />
      </button>
    </div>
    <div class="editor-grid editor-grid-single">
      <div class="editor-panel editor-main">
        <div class="editor-field">
          <div class="field-head">
            <label>LaTeX Formula</label>
            <div class="toggle-row">
              <label class="toggle">
                <input type="checkbox" id="formulaDisplayToggle" />
                <span class="toggle-slider"></span>
              </label>
              <span class="tiny">Display mode</span>
            </div>
          </div>
          <textarea id="formulaInput" placeholder="e.g. \\frac{a}{b}"></textarea>
          <div class="formula-preview">
            <div id="formulaRender" class="formula-render"></div>
          </div>
          <div class="field-error hidden" id="formulaError"></div>
        </div>
        <div class="controls" style="justify-content: space-between;">
          <div class="tiny" id="formulaTargetLabel">Target: Question</div>
          <div class="formula-actions">
            <button class="btn" id="cancelFormulaBtn" type="button">Cancel</button>
            <button class="btn save-primary formula-insert" id="insertFormulaBtn" type="button">Insert Formula</button>
          </div>
        </div>
      </div>
    </div>
  </dialog>

  <div id="sessionImageLightbox" class="session-image-lightbox hidden" aria-hidden="true">
    <img id="sessionImageLightboxImg" src="" alt="Expanded flashcard image" />
  </div>

</body>

</html>